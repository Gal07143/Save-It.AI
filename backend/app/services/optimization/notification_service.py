"""
Notification Service for AI Agent Alerts.

This module handles the creation and management of notifications
generated by various AI agents and analysis services.
"""
import json
from datetime import datetime
from typing import Optional, List, Dict, Any
from sqlalchemy.orm import Session

from backend.app.models import Notification, Site
from backend.app.models.base import NotificationType
from backend.app.schemas import NotificationCreate, NotificationResponse


class NotificationService:
    """
    Service for managing AI-generated notifications.
    
    This service is used by various agents to create alerts:
    - Gap Analysis Agent: Creates MISSING_METER notifications
    - Bill Validation Agent: Creates BILL_VARIANCE notifications
    - Peak Shaving Agent: Creates PEAK_SHAVING_ALERT notifications
    - Solar ROI Agent: Creates SOLAR_ROI_UPDATE notifications
    """

    def __init__(self, db: Session):
        """Initialize the service with a database session."""
        self.db = db

    def create_notification(
        self,
        site_id: int,
        notification_type: NotificationType,
        title: str,
        message: str,
        severity: str = "info",
        asset_id: Optional[int] = None,
        agent_name: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Notification:
        """
        Create a new notification.
        
        Args:
            site_id: The site ID
            notification_type: Type of notification
            title: Short title
            message: Detailed message
            severity: One of 'info', 'warning', 'critical'
            asset_id: Optional asset ID if related to specific asset
            agent_name: Name of the agent that created this notification
            metadata: Additional JSON metadata
            
        Returns:
            Created Notification object
        """
        notification = Notification(
            site_id=site_id,
            asset_id=asset_id,
            notification_type=notification_type,
            severity=severity,
            title=title,
            message=message,
            agent_name=agent_name,
            metadata=json.dumps(metadata) if metadata else None
        )

        self.db.add(notification)
        self.db.commit()
        self.db.refresh(notification)

        return notification

    def create_missing_meter_alert(
        self,
        site_id: int,
        asset_id: int,
        asset_name: str,
        is_critical: bool = False
    ) -> Notification:
        """
        Create a notification for a missing meter.
        
        Args:
            site_id: The site ID
            asset_id: The unmetered asset ID
            asset_name: Name of the asset
            is_critical: Whether the asset is critical
            
        Returns:
            Created Notification
        """
        severity = "critical" if is_critical else "warning"
        title = f"Missing Meter: {asset_name}"
        message = (
            f"Asset '{asset_name}' (ID: {asset_id}) requires metering but no "
            f"active meter is attached. This creates a gap in energy monitoring coverage."
        )

        return self.create_notification(
            site_id=site_id,
            notification_type=NotificationType.MISSING_METER,
            title=title,
            message=message,
            severity=severity,
            asset_id=asset_id,
            agent_name="GapAnalysisAgent",
            metadata={"asset_id": asset_id, "is_critical": is_critical}
        )

    def create_peak_shaving_alert(
        self,
        site_id: int,
        current_demand_kw: float,
        threshold_kw: float,
        potential_penalty: float
    ) -> Notification:
        """
        Create a peak shaving alert when demand approaches threshold.
        
        Args:
            site_id: The site ID
            current_demand_kw: Current power demand
            threshold_kw: Demand threshold from tariff
            potential_penalty: Estimated penalty cost
            
        Returns:
            Created Notification
        """
        overage_pct = (current_demand_kw / threshold_kw - 1) * 100

        if current_demand_kw > threshold_kw:
            severity = "critical"
            title = "Peak Demand Exceeded!"
            message = (
                f"Current demand ({current_demand_kw:.1f} kW) exceeds threshold "
                f"({threshold_kw:.1f} kW) by {overage_pct:.1f}%. "
                f"Estimated additional cost: ${potential_penalty:.2f}. "
                "Consider reducing non-essential loads immediately."
            )
        else:
            severity = "warning"
            remaining = threshold_kw - current_demand_kw
            title = "Peak Demand Warning"
            message = (
                f"Current demand ({current_demand_kw:.1f} kW) is approaching "
                f"threshold ({threshold_kw:.1f} kW). Only {remaining:.1f} kW "
                "headroom remaining. Monitor closely."
            )

        return self.create_notification(
            site_id=site_id,
            notification_type=NotificationType.PEAK_SHAVING_ALERT,
            title=title,
            message=message,
            severity=severity,
            agent_name="PeakShavingAgent",
            metadata={
                "current_demand_kw": current_demand_kw,
                "threshold_kw": threshold_kw,
                "potential_penalty": potential_penalty
            }
        )

    def create_bill_variance_alert(
        self,
        site_id: int,
        bill_id: int,
        variance_pct: float,
        bill_kwh: float,
        meter_kwh: float
    ) -> Notification:
        """
        Create a notification for significant bill variance.
        
        Args:
            site_id: The site ID
            bill_id: The bill ID
            variance_pct: Variance percentage
            bill_kwh: Bill total kWh
            meter_kwh: Meter total kWh
            
        Returns:
            Created Notification
        """
        abs_variance = abs(variance_pct)
        severity = "critical" if abs_variance > 10 else "warning"

        if variance_pct > 0:
            title = f"Bill Overcharge Detected ({variance_pct:.1f}%)"
            message = (
                f"Bill #{bill_id} shows {bill_kwh:.2f} kWh but meters only "
                f"recorded {meter_kwh:.2f} kWh. This represents a potential "
                f"overcharge of {variance_pct:.1f}%. Review billing accuracy."
            )
        else:
            title = f"Unmetered Consumption Detected ({abs_variance:.1f}%)"
            message = (
                f"Bill #{bill_id} shows {bill_kwh:.2f} kWh but meters recorded "
                f"{meter_kwh:.2f} kWh. This indicates {abs_variance:.1f}% of "
                "consumption is not being captured by meters."
            )

        return self.create_notification(
            site_id=site_id,
            notification_type=NotificationType.BILL_VARIANCE,
            title=title,
            message=message,
            severity=severity,
            agent_name="BillValidationAgent",
            metadata={
                "bill_id": bill_id,
                "variance_pct": variance_pct,
                "bill_kwh": bill_kwh,
                "meter_kwh": meter_kwh
            }
        )

    def get_unread_notifications(
        self, site_id: int, limit: int = 50
    ) -> List[Notification]:
        """Get unread notifications for a site."""
        return (
            self.db.query(Notification)
            .filter(Notification.site_id == site_id, Notification.is_read == 0)
            .order_by(Notification.created_at.desc())
            .limit(limit)
            .all()
        )

    def mark_as_read(self, notification_id: int) -> Optional[Notification]:
        """Mark a notification as read."""
        notification = (
            self.db.query(Notification)
            .filter(Notification.id == notification_id)
            .first()
        )
        if notification:
            notification.is_read = 1
            self.db.commit()
        return notification

    def mark_as_resolved(self, notification_id: int) -> Optional[Notification]:
        """Mark a notification as resolved."""
        notification = (
            self.db.query(Notification)
            .filter(Notification.id == notification_id)
            .first()
        )
        if notification:
            notification.is_resolved = 1
            notification.resolved_at = datetime.utcnow()
            self.db.commit()
        return notification


def get_notification_service(db: Session) -> NotificationService:
    """Factory function to create a NotificationService instance."""
    return NotificationService(db)
