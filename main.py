"""
SAVE-IT.AI - Main Entry Point

An AI-driven energy management platform that combines financial analysis
with electrical engineering (SLD/Digital Twin) to optimize energy usage
for B2B clients.
"""
import os
import sys

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = os.getenv("DATABASE_URL", "")

engine = create_engine(DATABASE_URL, pool_pre_ping=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()


def get_db():
    """Dependency to get database session."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


from datetime import datetime, date, time, timedelta
from enum import Enum as PyEnum
from typing import List, Optional, Dict, Any
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Float, Enum, Text, Date, Time
from sqlalchemy.orm import relationship
from pydantic import BaseModel, Field, ConfigDict


class AssetType(PyEnum):
    """Types of assets in the electrical hierarchy (SLD)."""
    MAIN_BREAKER = "main_breaker"
    SUB_PANEL = "sub_panel"
    DISTRIBUTION_BOARD = "distribution_board"
    CONSUMER = "consumer"
    TRANSFORMER = "transformer"
    GENERATOR = "generator"
    SOLAR_INVERTER = "solar_inverter"
    BATTERY_STORAGE = "battery_storage"


class NotificationType(PyEnum):
    """Types of notifications generated by AI agents."""
    MISSING_METER = "missing_meter"
    PEAK_SHAVING_ALERT = "peak_shaving_alert"
    BILL_VARIANCE = "bill_variance"
    ANOMALY_DETECTED = "anomaly_detected"
    SOLAR_ROI_UPDATE = "solar_roi_update"
    MAINTENANCE_REQUIRED = "maintenance_required"
    OPTIMIZATION_SUGGESTION = "optimization_suggestion"


class Site(Base):
    """Site model representing a physical facility or location."""
    __tablename__ = "sites"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False, index=True)
    address = Column(Text, nullable=True)
    city = Column(String(100), nullable=True)
    country = Column(String(100), nullable=True)
    latitude = Column(Float, nullable=True)
    longitude = Column(Float, nullable=True)
    timezone = Column(String(50), default="UTC")
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    assets = relationship("Asset", back_populates="site", cascade="all, delete-orphan")
    meters = relationship("Meter", back_populates="site", cascade="all, delete-orphan")
    bills = relationship("Bill", back_populates="site", cascade="all, delete-orphan")
    tariffs = relationship("Tariff", back_populates="site", cascade="all, delete-orphan")
    notifications = relationship("Notification", back_populates="site", cascade="all, delete-orphan")


class Asset(Base):
    """Asset model representing electrical components in the SLD hierarchy."""
    __tablename__ = "assets"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    parent_id = Column(Integer, ForeignKey("assets.id"), nullable=True, index=True)
    name = Column(String(255), nullable=False)
    asset_type = Column(Enum(AssetType), nullable=False)
    description = Column(Text, nullable=True)
    rated_capacity_kw = Column(Float, nullable=True)
    rated_voltage = Column(Float, nullable=True)
    rated_current = Column(Float, nullable=True)
    is_critical = Column(Integer, default=0)
    requires_metering = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    site = relationship("Site", back_populates="assets")
    parent = relationship("Asset", remote_side=[id], back_populates="children")
    children = relationship("Asset", back_populates="parent", cascade="all, delete-orphan")
    meter = relationship("Meter", back_populates="asset", uselist=False)


class Meter(Base):
    """Meter model representing a physical energy meter device."""
    __tablename__ = "meters"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    asset_id = Column(Integer, ForeignKey("assets.id"), nullable=True, index=True)
    meter_id = Column(String(100), unique=True, nullable=False, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    manufacturer = Column(String(100), nullable=True)
    model = Column(String(100), nullable=True)
    serial_number = Column(String(100), nullable=True)
    is_active = Column(Integer, default=1)
    is_bidirectional = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    site = relationship("Site", back_populates="meters")
    asset = relationship("Asset", back_populates="meter")
    readings = relationship("MeterReading", back_populates="meter", cascade="all, delete-orphan")


class MeterReading(Base):
    """MeterReading model for time-series energy data."""
    __tablename__ = "meter_readings"

    id = Column(Integer, primary_key=True, index=True)
    meter_id = Column(Integer, ForeignKey("meters.id"), nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    energy_kwh = Column(Float, nullable=False)
    power_kw = Column(Float, nullable=True)
    voltage = Column(Float, nullable=True)
    current = Column(Float, nullable=True)
    power_factor = Column(Float, nullable=True)
    reactive_power_kvar = Column(Float, nullable=True)
    apparent_power_kva = Column(Float, nullable=True)
    reading_type = Column(String(50), default="interval")
    created_at = Column(DateTime, default=datetime.utcnow)

    meter = relationship("Meter", back_populates="readings")


class Bill(Base):
    """Bill model representing a utility bill for a site."""
    __tablename__ = "bills"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    tariff_id = Column(Integer, ForeignKey("tariffs.id"), nullable=True, index=True)
    bill_number = Column(String(100), nullable=True, index=True)
    provider_name = Column(String(255), nullable=True)
    period_start = Column(Date, nullable=False)
    period_end = Column(Date, nullable=False)
    issue_date = Column(Date, nullable=True)
    due_date = Column(Date, nullable=True)
    total_kwh = Column(Float, nullable=False)
    total_amount = Column(Float, nullable=False)
    currency = Column(String(10), default="USD")
    peak_kwh = Column(Float, nullable=True)
    off_peak_kwh = Column(Float, nullable=True)
    demand_kw = Column(Float, nullable=True)
    power_factor_penalty = Column(Float, nullable=True)
    taxes = Column(Float, nullable=True)
    other_charges = Column(Float, nullable=True)
    notes = Column(Text, nullable=True)
    is_validated = Column(Integer, default=0)
    validation_variance_pct = Column(Float, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    site = relationship("Site", back_populates="bills")
    tariff = relationship("Tariff", back_populates="bills")
    line_items = relationship("BillLineItem", back_populates="bill", cascade="all, delete-orphan")


class BillLineItem(Base):
    """BillLineItem model for detailed bill breakdown."""
    __tablename__ = "bill_line_items"

    id = Column(Integer, primary_key=True, index=True)
    bill_id = Column(Integer, ForeignKey("bills.id"), nullable=False, index=True)
    description = Column(String(255), nullable=False)
    category = Column(String(100), nullable=True)
    quantity = Column(Float, nullable=True)
    unit = Column(String(50), nullable=True)
    unit_price = Column(Float, nullable=True)
    amount = Column(Float, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    bill = relationship("Bill", back_populates="line_items")


class Tariff(Base):
    """Tariff model representing a utility pricing structure."""
    __tablename__ = "tariffs"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    provider_name = Column(String(255), nullable=True)
    effective_from = Column(DateTime, nullable=True)
    effective_to = Column(DateTime, nullable=True)
    currency = Column(String(10), default="USD")
    fixed_charge = Column(Float, default=0.0)
    demand_charge_per_kw = Column(Float, nullable=True)
    power_factor_threshold = Column(Float, nullable=True)
    power_factor_penalty_rate = Column(Float, nullable=True)
    is_active = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    site = relationship("Site", back_populates="tariffs")
    rates = relationship("TariffRate", back_populates="tariff", cascade="all, delete-orphan")
    bills = relationship("Bill", back_populates="tariff")


class TariffRate(Base):
    """TariffRate model for time-of-use pricing periods."""
    __tablename__ = "tariff_rates"

    id = Column(Integer, primary_key=True, index=True)
    tariff_id = Column(Integer, ForeignKey("tariffs.id"), nullable=False, index=True)
    name = Column(String(100), nullable=False)
    rate_per_kwh = Column(Float, nullable=False)
    time_start = Column(Time, nullable=True)
    time_end = Column(Time, nullable=True)
    days_of_week = Column(String(50), nullable=True)
    season = Column(String(50), nullable=True)
    tier_min_kwh = Column(Float, nullable=True)
    tier_max_kwh = Column(Float, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    tariff = relationship("Tariff", back_populates="rates")


class Notification(Base):
    """Notification model for AI-generated alerts."""
    __tablename__ = "notifications"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    asset_id = Column(Integer, ForeignKey("assets.id"), nullable=True, index=True)
    notification_type = Column(Enum(NotificationType), nullable=False)
    severity = Column(String(20), default="info")
    title = Column(String(255), nullable=False)
    message = Column(Text, nullable=False)
    is_read = Column(Integer, default=0)
    is_resolved = Column(Integer, default=0)
    agent_name = Column(String(100), nullable=True)
    extra_data = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    resolved_at = Column(DateTime, nullable=True)

    site = relationship("Site", back_populates="notifications")


# ============================================================================
# ENTERPRISE EDITION MODELS
# ============================================================================

class DataSourceType(PyEnum):
    """Types of data sources for integration layer."""
    MODBUS_TCP = "modbus_tcp"
    MODBUS_RTU = "modbus_rtu"
    BACNET = "bacnet"
    CSV_IMPORT = "csv_import"
    EXTERNAL_API = "external_api"
    MANUAL = "manual"


class InvoiceStatus(PyEnum):
    """Status of tenant invoices."""
    DRAFT = "draft"
    PENDING = "pending"
    SENT = "sent"
    PAID = "paid"
    OVERDUE = "overdue"
    CANCELLED = "cancelled"


class DataSource(Base):
    """DataSource model for integration layer - connects to external systems."""
    __tablename__ = "data_sources"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    name = Column(String(255), nullable=False)
    source_type = Column(Enum(DataSourceType), nullable=False)
    connection_string = Column(Text, nullable=True)
    host = Column(String(255), nullable=True)
    port = Column(Integer, nullable=True)
    slave_id = Column(Integer, nullable=True)
    polling_interval_seconds = Column(Integer, default=60)
    is_active = Column(Integer, default=1)
    last_poll_at = Column(DateTime, nullable=True)
    last_error = Column(Text, nullable=True)
    config_json = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    measurements = relationship("Measurement", back_populates="data_source", cascade="all, delete-orphan")


class Measurement(Base):
    """Measurement model for normalized meter readings from all data sources.
    
    This table should be converted to a TimescaleDB hypertable for high-frequency data.
    """
    __tablename__ = "measurements"

    id = Column(Integer, primary_key=True, index=True)
    data_source_id = Column(Integer, ForeignKey("data_sources.id"), nullable=False, index=True)
    meter_id = Column(Integer, ForeignKey("meters.id"), nullable=True, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    value = Column(Float, nullable=False)
    unit = Column(String(50), nullable=False)
    quality = Column(String(20), default="good")
    raw_value = Column(Float, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    data_source = relationship("DataSource", back_populates="measurements")


class Tenant(Base):
    """Tenant model for sub-billing in multi-tenant facilities."""
    __tablename__ = "tenants"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    name = Column(String(255), nullable=False)
    contact_name = Column(String(255), nullable=True)
    contact_email = Column(String(255), nullable=True)
    contact_phone = Column(String(50), nullable=True)
    billing_address = Column(Text, nullable=True)
    tax_id = Column(String(100), nullable=True)
    is_active = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    lease_contracts = relationship("LeaseContract", back_populates="tenant", cascade="all, delete-orphan")
    invoices = relationship("Invoice", back_populates="tenant", cascade="all, delete-orphan")


class LeaseContract(Base):
    """LeaseContract model defining billing rules for a tenant."""
    __tablename__ = "lease_contracts"

    id = Column(Integer, primary_key=True, index=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False, index=True)
    meter_id = Column(Integer, ForeignKey("meters.id"), nullable=True, index=True)
    name = Column(String(255), nullable=False)
    start_date = Column(Date, nullable=False)
    end_date = Column(Date, nullable=True)
    rate_per_kwh = Column(Float, nullable=False)
    fixed_monthly_fee = Column(Float, default=0.0)
    loss_factor_percent = Column(Float, default=0.0)
    demand_charge_per_kw = Column(Float, default=0.0)
    min_monthly_charge = Column(Float, default=0.0)
    billing_day = Column(Integer, default=1)
    is_active = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    tenant = relationship("Tenant", back_populates="lease_contracts")


class Invoice(Base):
    """Invoice model for tenant billing."""
    __tablename__ = "invoices"

    id = Column(Integer, primary_key=True, index=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False, index=True)
    lease_contract_id = Column(Integer, ForeignKey("lease_contracts.id"), nullable=True, index=True)
    invoice_number = Column(String(100), unique=True, nullable=False, index=True)
    billing_period_start = Column(Date, nullable=False)
    billing_period_end = Column(Date, nullable=False)
    consumption_kwh = Column(Float, default=0.0)
    peak_demand_kw = Column(Float, nullable=True)
    energy_charge = Column(Float, default=0.0)
    demand_charge = Column(Float, default=0.0)
    fixed_fee = Column(Float, default=0.0)
    loss_charge = Column(Float, default=0.0)
    subtotal = Column(Float, default=0.0)
    tax_amount = Column(Float, default=0.0)
    total_amount = Column(Float, default=0.0)
    status = Column(Enum(InvoiceStatus), default=InvoiceStatus.DRAFT)
    due_date = Column(Date, nullable=True)
    paid_date = Column(Date, nullable=True)
    notes = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    tenant = relationship("Tenant", back_populates="invoices")


class BatterySpecs(Base):
    """BatterySpecs model for BESS financial analysis."""
    __tablename__ = "battery_specs"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    name = Column(String(255), nullable=False)
    capacity_kwh = Column(Float, nullable=False)
    power_rating_kw = Column(Float, nullable=False)
    round_trip_efficiency = Column(Float, default=0.90)
    depth_of_discharge = Column(Float, default=0.90)
    cycle_life = Column(Integer, default=6000)
    capex_total = Column(Float, nullable=False)
    opex_annual = Column(Float, default=0.0)
    warranty_years = Column(Integer, default=10)
    degradation_rate_annual = Column(Float, default=0.02)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class SiteCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=255)
    address: Optional[str] = None
    city: Optional[str] = None
    country: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    timezone: str = "UTC"


class SiteUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    address: Optional[str] = None
    city: Optional[str] = None
    country: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    timezone: Optional[str] = None


class SiteResponse(BaseModel):
    id: int
    name: str
    address: Optional[str] = None
    city: Optional[str] = None
    country: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    timezone: str
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class AssetCreate(BaseModel):
    site_id: int
    parent_id: Optional[int] = None
    name: str = Field(..., min_length=1, max_length=255)
    asset_type: AssetType
    description: Optional[str] = None
    rated_capacity_kw: Optional[float] = None
    rated_voltage: Optional[float] = None
    rated_current: Optional[float] = None
    is_critical: bool = False
    requires_metering: bool = True


class AssetUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    asset_type: Optional[AssetType] = None
    description: Optional[str] = None
    parent_id: Optional[int] = None
    rated_capacity_kw: Optional[float] = None
    rated_voltage: Optional[float] = None
    rated_current: Optional[float] = None
    is_critical: Optional[bool] = None
    requires_metering: Optional[bool] = None


class AssetResponse(BaseModel):
    id: int
    site_id: int
    parent_id: Optional[int] = None
    name: str
    asset_type: AssetType
    description: Optional[str] = None
    rated_capacity_kw: Optional[float] = None
    rated_voltage: Optional[float] = None
    rated_current: Optional[float] = None
    is_critical: bool = False
    requires_metering: bool = True
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class AssetTreeNode(BaseModel):
    id: int
    name: str
    asset_type: AssetType
    has_meter: bool = False
    meter_id: Optional[str] = None
    children: List["AssetTreeNode"] = []

    model_config = ConfigDict(from_attributes=True)


AssetTreeNode.model_rebuild()


class MeterCreate(BaseModel):
    site_id: int
    asset_id: Optional[int] = None
    meter_id: str = Field(..., min_length=1, max_length=100)
    name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    manufacturer: Optional[str] = None
    model: Optional[str] = None
    serial_number: Optional[str] = None
    is_active: bool = True
    is_bidirectional: bool = False


class MeterUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    description: Optional[str] = None
    asset_id: Optional[int] = None
    manufacturer: Optional[str] = None
    model: Optional[str] = None
    serial_number: Optional[str] = None
    is_active: Optional[bool] = None
    is_bidirectional: Optional[bool] = None


class MeterResponse(BaseModel):
    id: int
    site_id: int
    asset_id: Optional[int] = None
    meter_id: str
    name: str
    description: Optional[str] = None
    manufacturer: Optional[str] = None
    model: Optional[str] = None
    serial_number: Optional[str] = None
    is_active: bool
    is_bidirectional: bool
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class MeterReadingCreate(BaseModel):
    meter_id: int
    timestamp: datetime
    energy_kwh: float
    power_kw: Optional[float] = None
    voltage: Optional[float] = None
    current: Optional[float] = None
    power_factor: Optional[float] = None
    reactive_power_kvar: Optional[float] = None
    apparent_power_kva: Optional[float] = None
    reading_type: str = "interval"


class MeterReadingResponse(BaseModel):
    id: int
    meter_id: int
    timestamp: datetime
    energy_kwh: float
    power_kw: Optional[float] = None
    voltage: Optional[float] = None
    current: Optional[float] = None
    power_factor: Optional[float] = None
    reactive_power_kvar: Optional[float] = None
    apparent_power_kva: Optional[float] = None
    reading_type: str
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class BillLineItemCreate(BaseModel):
    description: str
    category: Optional[str] = None
    quantity: Optional[float] = None
    unit: Optional[str] = None
    unit_price: Optional[float] = None
    amount: float


class BillLineItemResponse(BaseModel):
    id: int
    bill_id: int
    description: str
    category: Optional[str] = None
    quantity: Optional[float] = None
    unit: Optional[str] = None
    unit_price: Optional[float] = None
    amount: float
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class BillCreate(BaseModel):
    site_id: int
    tariff_id: Optional[int] = None
    bill_number: Optional[str] = None
    provider_name: Optional[str] = None
    period_start: date
    period_end: date
    issue_date: Optional[date] = None
    due_date: Optional[date] = None
    total_kwh: float
    total_amount: float
    currency: str = "USD"
    peak_kwh: Optional[float] = None
    off_peak_kwh: Optional[float] = None
    demand_kw: Optional[float] = None
    power_factor_penalty: Optional[float] = None
    taxes: Optional[float] = None
    other_charges: Optional[float] = None
    notes: Optional[str] = None
    line_items: List[BillLineItemCreate] = []


class BillUpdate(BaseModel):
    bill_number: Optional[str] = None
    provider_name: Optional[str] = None
    period_start: Optional[date] = None
    period_end: Optional[date] = None
    issue_date: Optional[date] = None
    due_date: Optional[date] = None
    total_kwh: Optional[float] = None
    total_amount: Optional[float] = None
    currency: Optional[str] = None
    tariff_id: Optional[int] = None
    notes: Optional[str] = None


class BillResponse(BaseModel):
    id: int
    site_id: int
    tariff_id: Optional[int] = None
    bill_number: Optional[str] = None
    provider_name: Optional[str] = None
    period_start: date
    period_end: date
    issue_date: Optional[date] = None
    due_date: Optional[date] = None
    total_kwh: float
    total_amount: float
    currency: str
    peak_kwh: Optional[float] = None
    off_peak_kwh: Optional[float] = None
    demand_kw: Optional[float] = None
    power_factor_penalty: Optional[float] = None
    taxes: Optional[float] = None
    other_charges: Optional[float] = None
    notes: Optional[str] = None
    is_validated: bool
    validation_variance_pct: Optional[float] = None
    created_at: datetime
    updated_at: datetime
    line_items: List[BillLineItemResponse] = []

    model_config = ConfigDict(from_attributes=True)


class BillValidationResult(BaseModel):
    bill_id: int
    is_valid: bool
    bill_total_kwh: float
    meter_total_kwh: float
    variance_kwh: float
    variance_percentage: float
    message: str


class UnmeteredAsset(BaseModel):
    asset_id: int
    asset_name: str
    asset_type: AssetType
    parent_id: Optional[int] = None
    parent_name: Optional[str] = None
    rated_capacity_kw: Optional[float] = None
    is_critical: bool = False
    hierarchy_path: List[str] = []


class GapAnalysisResult(BaseModel):
    site_id: int
    site_name: str
    total_assets: int
    metered_assets: int
    unmetered_assets: int
    coverage_percentage: float
    critical_unmetered_count: int
    unmetered_asset_list: List[UnmeteredAsset] = []
    recommendations: List[str] = []


class NotificationResponse(BaseModel):
    id: int
    site_id: int
    asset_id: Optional[int] = None
    notification_type: NotificationType
    severity: str
    title: str
    message: str
    is_read: bool
    is_resolved: bool
    agent_name: Optional[str] = None
    extra_data: Optional[str] = None
    created_at: datetime
    resolved_at: Optional[datetime] = None

    model_config = ConfigDict(from_attributes=True)


class SolarROIInput(BaseModel):
    """Input parameters for Solar ROI calculation."""
    annual_consumption_kwh: float
    average_electricity_rate: float
    system_size_kw: float
    installation_cost: float
    annual_solar_production_kwh_per_kw: float = 1400
    annual_degradation_rate: float = 0.005
    maintenance_cost_annual: float = 0.0
    incentive_amount: float = 0.0
    net_metering_rate: Optional[float] = None
    analysis_period_years: int = 25
    inflation_rate: float = 0.03


class SolarROIResult(BaseModel):
    """Result of Solar ROI calculation."""
    system_size_kw: float
    installation_cost: float
    year_one_production_kwh: float
    year_one_savings: float
    simple_payback_years: float
    net_present_value: float
    internal_rate_of_return: float
    lifetime_savings: float
    break_even_year: Optional[int]
    annual_projections: List[dict]


# ============================================================================
# ENTERPRISE EDITION SCHEMAS
# ============================================================================

class TenantCreate(BaseModel):
    """Schema for creating a tenant."""
    site_id: int
    name: str = Field(..., min_length=1, max_length=255)
    contact_name: Optional[str] = None
    contact_email: Optional[str] = None
    contact_phone: Optional[str] = None
    billing_address: Optional[str] = None
    tax_id: Optional[str] = None


class TenantResponse(BaseModel):
    """Response schema for tenant."""
    id: int
    site_id: int
    name: str
    contact_name: Optional[str] = None
    contact_email: Optional[str] = None
    contact_phone: Optional[str] = None
    billing_address: Optional[str] = None
    tax_id: Optional[str] = None
    is_active: bool
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class LeaseContractCreate(BaseModel):
    """Schema for creating a lease contract."""
    tenant_id: int
    meter_id: Optional[int] = None
    name: str = Field(..., min_length=1, max_length=255)
    start_date: date
    end_date: Optional[date] = None
    rate_per_kwh: float
    fixed_monthly_fee: float = 0.0
    loss_factor_percent: float = 0.0
    demand_charge_per_kw: float = 0.0
    min_monthly_charge: float = 0.0
    billing_day: int = 1


class LeaseContractResponse(BaseModel):
    """Response schema for lease contract."""
    id: int
    tenant_id: int
    meter_id: Optional[int] = None
    name: str
    start_date: date
    end_date: Optional[date] = None
    rate_per_kwh: float
    fixed_monthly_fee: float
    loss_factor_percent: float
    demand_charge_per_kw: float
    is_active: bool
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class InvoiceResponse(BaseModel):
    """Response schema for invoice."""
    id: int
    tenant_id: int
    invoice_number: str
    billing_period_start: date
    billing_period_end: date
    consumption_kwh: float
    peak_demand_kw: Optional[float] = None
    energy_charge: float
    demand_charge: float
    fixed_fee: float
    loss_charge: float
    subtotal: float
    tax_amount: float
    total_amount: float
    status: InvoiceStatus
    due_date: Optional[date] = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class BESSSimulationInput(BaseModel):
    """Input parameters for BESS financial simulation."""
    load_profile_kwh: List[float] = Field(..., description="8760 hourly load values (kWh) for a year")
    tariff_rates: List[float] = Field(..., description="8760 hourly electricity rates ($/kWh)")
    demand_charges: Optional[List[float]] = Field(None, description="12 monthly demand charges ($/kW)")
    battery_capacity_kwh: float = Field(..., gt=0)
    battery_power_kw: float = Field(..., gt=0)
    round_trip_efficiency: float = Field(default=0.90, ge=0.5, le=1.0)
    depth_of_discharge: float = Field(default=0.90, ge=0.5, le=1.0)
    capex: float = Field(..., gt=0)
    opex_annual: float = Field(default=0.0, ge=0)
    analysis_years: int = Field(default=15, ge=1, le=30)
    discount_rate: float = Field(default=0.08, ge=0, le=0.3)
    degradation_rate: float = Field(default=0.02, ge=0, le=0.1)


class BESSSimulationResult(BaseModel):
    """Result of BESS financial simulation."""
    arbitrage_savings_year1: float
    peak_shaving_savings_year1: float
    total_savings_year1: float
    simple_payback_years: float
    net_present_value: float
    internal_rate_of_return: Optional[float]
    lifetime_savings: float
    annual_projections: List[Dict[str, Any]]
    monthly_peak_reduction: List[float]


class DataSourceCreate(BaseModel):
    """Schema for creating a data source."""
    site_id: int
    name: str = Field(..., min_length=1, max_length=255)
    source_type: DataSourceType
    host: Optional[str] = None
    port: Optional[int] = None
    slave_id: Optional[int] = None
    polling_interval_seconds: int = 60
    config_json: Optional[str] = None


class DataSourceResponse(BaseModel):
    """Response schema for data source."""
    id: int
    site_id: int
    name: str
    source_type: DataSourceType
    host: Optional[str] = None
    port: Optional[int] = None
    polling_interval_seconds: int
    is_active: bool
    last_poll_at: Optional[datetime] = None
    last_error: Optional[str] = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class MeasurementCreate(BaseModel):
    """Schema for normalized measurement data."""
    data_source_id: int
    meter_id: Optional[int] = None
    timestamp: datetime
    value: float
    unit: str
    quality: str = "good"
    raw_value: Optional[float] = None


def init_db():
    """Initialize database tables."""
    Base.metadata.create_all(bind=engine)


def perform_gap_analysis(db, site_id: int) -> GapAnalysisResult:
    """
    Perform gap analysis for a given site.
    
    Compares the SLD asset tree with connected meters to identify
    unmetered nodes that require monitoring.
    
    Algorithm:
    1. Get all assets for the site
    2. Get all active meters for the site
    3. Find assets that require metering but have no meter
    4. Generate recommendations
    """
    site = db.query(Site).filter(Site.id == site_id).first()
    if not site:
        raise ValueError(f"Site with ID {site_id} not found")

    assets = db.query(Asset).filter(Asset.site_id == site_id).all()
    active_meters = db.query(Meter).filter(
        Meter.site_id == site_id,
        Meter.is_active == 1
    ).all()
    
    metered_asset_ids = {
        meter.asset_id for meter in active_meters if meter.asset_id is not None
    }

    asset_dict = {asset.id: asset for asset in assets}
    assets_requiring_metering = [a for a in assets if a.requires_metering]
    
    unmetered_assets: List[UnmeteredAsset] = []
    critical_unmetered_count = 0

    for asset in assets_requiring_metering:
        if asset.id not in metered_asset_ids:
            path = []
            current = asset
            while current:
                path.insert(0, current.name)
                if current.parent_id:
                    current = asset_dict.get(current.parent_id)
                else:
                    break

            parent_name = None
            if asset.parent_id:
                parent = asset_dict.get(asset.parent_id)
                parent_name = parent.name if parent else None

            unmetered_asset = UnmeteredAsset(
                asset_id=asset.id,
                asset_name=asset.name,
                asset_type=asset.asset_type,
                parent_id=asset.parent_id,
                parent_name=parent_name,
                rated_capacity_kw=asset.rated_capacity_kw,
                is_critical=bool(asset.is_critical),
                hierarchy_path=path
            )
            unmetered_assets.append(unmetered_asset)
            if asset.is_critical:
                critical_unmetered_count += 1

    total_requiring_metering = len(assets_requiring_metering)
    metered_count = total_requiring_metering - len(unmetered_assets)
    coverage_percentage = (
        (metered_count / total_requiring_metering * 100)
        if total_requiring_metering > 0 else 100.0
    )

    recommendations = []
    if critical_unmetered_count > 0:
        recommendations.append(
            f"CRITICAL: {critical_unmetered_count} critical asset(s) are unmetered."
        )
    if coverage_percentage < 50:
        recommendations.append(f"Coverage is very low ({coverage_percentage:.1f}%).")
    elif coverage_percentage < 80:
        recommendations.append(f"Coverage is moderate ({coverage_percentage:.1f}%).")

    return GapAnalysisResult(
        site_id=site_id,
        site_name=site.name,
        total_assets=len(assets),
        metered_assets=metered_count,
        unmetered_assets=len(unmetered_assets),
        coverage_percentage=round(coverage_percentage, 2),
        critical_unmetered_count=critical_unmetered_count,
        unmetered_asset_list=unmetered_assets,
        recommendations=recommendations
    )


def validate_bill(db, bill_id: int) -> BillValidationResult:
    """
    Validate a bill by comparing with meter readings.
    
    Cross-references the bill's total kWh with the sum of
    meter readings for the same period.
    """
    bill = db.query(Bill).filter(Bill.id == bill_id).first()
    if not bill:
        raise ValueError(f"Bill with ID {bill_id} not found")

    period_start = datetime.combine(bill.period_start, datetime.min.time())
    period_end = datetime.combine(bill.period_end, datetime.max.time())

    meters = db.query(Meter).filter(
        Meter.site_id == bill.site_id,
        Meter.is_active == 1
    ).all()

    meter_total_kwh = 0.0
    for meter in meters:
        readings = db.query(MeterReading).filter(
            MeterReading.meter_id == meter.id,
            MeterReading.timestamp >= period_start,
            MeterReading.timestamp <= period_end
        ).all()
        if readings:
            meter_total_kwh += sum(r.energy_kwh for r in readings)

    variance_kwh = bill.total_kwh - meter_total_kwh
    variance_percentage = (
        (variance_kwh / bill.total_kwh * 100) if bill.total_kwh > 0 else 0.0
    )

    is_valid = abs(variance_percentage) <= 2.0

    if is_valid:
        message = f"Bill validated. Variance of {variance_percentage:.2f}% is within tolerance."
    elif abs(variance_percentage) <= 5.0:
        message = f"Minor variance detected ({variance_percentage:.2f}%)."
    else:
        message = f"Significant variance detected ({variance_percentage:.2f}%)."

    bill.is_validated = 1 if is_valid else 0
    bill.validation_variance_pct = variance_percentage
    db.commit()

    return BillValidationResult(
        bill_id=bill_id,
        is_valid=is_valid,
        bill_total_kwh=bill.total_kwh,
        meter_total_kwh=meter_total_kwh,
        variance_kwh=variance_kwh,
        variance_percentage=round(variance_percentage, 2),
        message=message
    )


def calculate_solar_roi(inputs: SolarROIInput) -> SolarROIResult:
    """
    Calculate solar PV system ROI.
    
    Formulas:
    - Year N Production = System Size * kWh/kW * (1 - degradation_rate)^(N-1)
    - Year N Savings = Production_N * Rate * (1 + inflation)^(N-1)
    - Simple Payback = Net Cost / Year 1 Savings
    - NPV = Sum of discounted cash flows
    - IRR = Discount rate that makes NPV = 0
    """
    net_cost = inputs.installation_cost - inputs.incentive_amount
    year_one_production = inputs.system_size_kw * inputs.annual_solar_production_kwh_per_kw
    export_rate = inputs.net_metering_rate or inputs.average_electricity_rate
    discount_rate = 0.06

    annual_projections = []
    cumulative_savings = 0.0
    cumulative_cash_flow = -net_cost
    break_even_year = None

    for year in range(1, inputs.analysis_period_years + 1):
        degradation_factor = (1 - inputs.annual_degradation_rate) ** (year - 1)
        production = year_one_production * degradation_factor
        inflation_factor = (1 + inputs.inflation_rate) ** (year - 1)
        current_rate = inputs.average_electricity_rate * inflation_factor
        
        self_consumption = min(production, inputs.annual_consumption_kwh * degradation_factor)
        export = max(0, production - self_consumption)
        savings = (self_consumption * current_rate) + (export * export_rate * inflation_factor)
        net_annual = savings - inputs.maintenance_cost_annual
        
        cumulative_savings += net_annual
        cumulative_cash_flow += net_annual

        if break_even_year is None and cumulative_cash_flow >= 0:
            break_even_year = year

        annual_projections.append({
            "year": year,
            "production_kwh": round(production, 2),
            "savings": round(net_annual, 2),
            "cumulative_savings": round(cumulative_savings, 2),
            "cumulative_cash_flow": round(cumulative_cash_flow, 2)
        })

    import numpy_financial as npf
    
    year_one_savings = annual_projections[0]["savings"]
    simple_payback = net_cost / year_one_savings if year_one_savings > 0 else float('inf')

    cash_flows = [-net_cost] + [p["savings"] for p in annual_projections]
    npv = npf.npv(discount_rate, cash_flows)
    
    try:
        irr = npf.irr(cash_flows)
        if irr is None or not (-1 < irr < 10):
            irr = 0.0
    except Exception:
        irr = 0.0

    return SolarROIResult(
        system_size_kw=inputs.system_size_kw,
        installation_cost=inputs.installation_cost,
        year_one_production_kwh=round(year_one_production, 2),
        year_one_savings=round(year_one_savings, 2),
        simple_payback_years=round(simple_payback, 2),
        net_present_value=round(npv, 2),
        internal_rate_of_return=round(irr * 100, 2),
        lifetime_savings=round(cumulative_savings, 2),
        break_even_year=break_even_year,
        annual_projections=annual_projections
    )


# ============================================================================
# BESS FINANCIAL ANALYZER (Enterprise Edition)
# ============================================================================

def simulate_bess_operation(inputs: BESSSimulationInput) -> BESSSimulationResult:
    """
    Simulate battery energy storage system (BESS) operation for financial analysis.
    
    Algorithm:
    1. Iterate through 8760 hourly intervals
    2. For each hour: decide to charge (low price) or discharge (high price)
    3. Track arbitrage savings from TOU shifting
    4. Calculate monthly peak reduction for demand charge savings
    5. Project savings over analysis period with degradation
    6. Calculate NPV and IRR using numpy_financial
    
    Peak Shaving Logic:
    - Identify monthly peak demand periods
    - Discharge battery to reduce demand peaks
    - Calculate demand charge savings
    
    Arbitrage Logic:
    - Charge when electricity price is below daily average
    - Discharge when price is above daily average
    """
    import numpy_financial as npf
    
    load_profile = inputs.load_profile_kwh
    tariff_rates = inputs.tariff_rates
    battery_kwh = inputs.battery_capacity_kwh
    battery_kw = inputs.battery_power_kw
    efficiency = inputs.round_trip_efficiency
    dod = inputs.depth_of_discharge
    
    usable_capacity = battery_kwh * dod
    hours_per_year = 8760
    hours_per_month = [744, 672, 744, 720, 744, 720, 744, 744, 720, 744, 720, 744]
    
    soc = usable_capacity * 0.5
    arbitrage_savings = 0.0
    monthly_peaks_original = [0.0] * 12
    monthly_peaks_with_bess = [0.0] * 12
    
    hour_to_month = []
    hour_idx = 0
    for month_idx, hours_in_month in enumerate(hours_per_month):
        for _ in range(hours_in_month):
            if hour_idx < hours_per_year:
                hour_to_month.append(month_idx)
                hour_idx += 1
    
    while len(hour_to_month) < hours_per_year:
        hour_to_month.append(11)
    
    for hour in range(hours_per_year):
        load = load_profile[hour] if hour < len(load_profile) else 0
        rate = tariff_rates[hour] if hour < len(tariff_rates) else 0.1
        month = hour_to_month[hour]
        
        monthly_peaks_original[month] = max(monthly_peaks_original[month], load)
        
        day_start = (hour // 24) * 24
        day_end = min(day_start + 24, hours_per_year)
        day_rates = tariff_rates[day_start:day_end] if day_end <= len(tariff_rates) else [0.1] * 24
        avg_rate = sum(day_rates) / len(day_rates) if day_rates else 0.1
        
        if rate < avg_rate * 0.9 and soc < usable_capacity:
            charge_amount = min(battery_kw, usable_capacity - soc)
            soc += charge_amount
            arbitrage_savings -= charge_amount * rate
        elif rate > avg_rate * 1.1 and soc > 0:
            discharge_amount = min(battery_kw, soc)
            soc -= discharge_amount
            arbitrage_savings += discharge_amount * rate * efficiency
        
        net_load = load - (battery_kw if soc > battery_kw else soc) * 0.3
        monthly_peaks_with_bess[month] = max(monthly_peaks_with_bess[month], max(0, net_load))
    
    monthly_peak_reduction = [
        round(orig - reduced, 2)
        for orig, reduced in zip(monthly_peaks_original, monthly_peaks_with_bess)
    ]
    
    demand_charges = inputs.demand_charges or [15.0] * 12
    peak_shaving_savings = sum(
        reduction * charge
        for reduction, charge in zip(monthly_peak_reduction, demand_charges)
    )
    
    total_savings_year1 = arbitrage_savings + peak_shaving_savings
    
    annual_projections = []
    cash_flows = [-inputs.capex]
    cumulative = -inputs.capex
    
    for year in range(1, inputs.analysis_years + 1):
        degradation_factor = (1 - inputs.degradation_rate) ** (year - 1)
        year_savings = total_savings_year1 * degradation_factor - inputs.opex_annual
        cumulative += year_savings
        cash_flows.append(year_savings)
        
        annual_projections.append({
            "year": year,
            "degradation_factor": round(degradation_factor, 3),
            "gross_savings": round(total_savings_year1 * degradation_factor, 2),
            "net_savings": round(year_savings, 2),
            "cumulative": round(cumulative, 2)
        })
    
    simple_payback = (
        inputs.capex / total_savings_year1
        if total_savings_year1 > 0
        else float('inf')
    )
    
    npv = npf.npv(inputs.discount_rate, cash_flows)
    
    try:
        irr = npf.irr(cash_flows)
        if irr is None or not (-1 < irr < 10):
            irr = None
        else:
            irr = round(irr * 100, 2)
    except Exception:
        irr = None
    
    lifetime_savings = sum(p["net_savings"] for p in annual_projections)
    
    return BESSSimulationResult(
        arbitrage_savings_year1=round(arbitrage_savings, 2),
        peak_shaving_savings_year1=round(peak_shaving_savings, 2),
        total_savings_year1=round(total_savings_year1, 2),
        simple_payback_years=round(simple_payback, 2),
        net_present_value=round(npv, 2),
        internal_rate_of_return=irr,
        lifetime_savings=round(lifetime_savings, 2),
        annual_projections=annual_projections,
        monthly_peak_reduction=monthly_peak_reduction
    )


# ============================================================================
# INTEGRATION LAYER - DATA SOURCES (Enterprise Edition)
# ============================================================================

from abc import ABC, abstractmethod
from typing import Generator


class DataSourceDriver(ABC):
    """Abstract base class for data source drivers."""
    
    @abstractmethod
    def connect(self) -> bool:
        """Establish connection to the data source."""
        pass
    
    @abstractmethod
    def disconnect(self) -> None:
        """Close connection to the data source."""
        pass
    
    @abstractmethod
    def poll(self) -> Generator[MeasurementCreate, None, None]:
        """Poll data from the source and yield normalized measurements."""
        pass
    
    @abstractmethod
    def is_connected(self) -> bool:
        """Check if connection is active."""
        pass


class ModbusTCPDriver(DataSourceDriver):
    """
    Modbus TCP driver for polling data from Modbus devices.
    
    This is a skeleton implementation showing the structure for
    integrating with pymodbus library.
    """
    
    def __init__(
        self,
        data_source_id: int,
        host: str,
        port: int = 502,
        slave_id: int = 1,
        registers: Optional[List[Dict[str, Any]]] = None
    ):
        self.data_source_id = data_source_id
        self.host = host
        self.port = port
        self.slave_id = slave_id
        self.registers = registers or []
        self._client = None
        self._connected = False
    
    def connect(self) -> bool:
        """Establish Modbus TCP connection."""
        try:
            from pymodbus.client import ModbusTcpClient
            
            self._client = ModbusTcpClient(
                host=self.host,
                port=self.port
            )
            self._connected = self._client.connect()
            return self._connected
        except Exception as e:
            self._connected = False
            raise ConnectionError(f"Failed to connect to Modbus device: {e}")
    
    def disconnect(self) -> None:
        """Close Modbus connection."""
        if self._client:
            self._client.close()
        self._connected = False
    
    def is_connected(self) -> bool:
        """Check if Modbus connection is active."""
        return self._connected and self._client is not None
    
    def poll(self) -> Generator[MeasurementCreate, None, None]:
        """
        Poll all configured registers and yield normalized measurements.
        
        Register config example:
        {
            "address": 100,
            "count": 2,
            "type": "holding",
            "data_type": "float32",
            "unit": "kWh",
            "meter_id": 1,
            "scale_factor": 1.0
        }
        """
        if not self.is_connected():
            raise ConnectionError("Not connected to Modbus device")
        
        for reg_config in self.registers:
            try:
                address = reg_config.get("address", 0)
                count = reg_config.get("count", 1)
                reg_type = reg_config.get("type", "holding")
                
                if reg_type == "holding":
                    result = self._client.read_holding_registers(
                        address=address,
                        count=count,
                        slave=self.slave_id
                    )
                elif reg_type == "input":
                    result = self._client.read_input_registers(
                        address=address,
                        count=count,
                        slave=self.slave_id
                    )
                else:
                    continue
                
                if result.isError():
                    continue
                
                raw_value = float(result.registers[0]) if result.registers else 0.0
                scale_factor = reg_config.get("scale_factor", 1.0)
                value = raw_value * scale_factor
                
                yield MeasurementCreate(
                    data_source_id=self.data_source_id,
                    meter_id=reg_config.get("meter_id"),
                    timestamp=datetime.utcnow(),
                    value=value,
                    unit=reg_config.get("unit", "kWh"),
                    quality="good",
                    raw_value=raw_value
                )
            except Exception:
                yield MeasurementCreate(
                    data_source_id=self.data_source_id,
                    meter_id=reg_config.get("meter_id"),
                    timestamp=datetime.utcnow(),
                    value=0.0,
                    unit=reg_config.get("unit", "kWh"),
                    quality="bad",
                    raw_value=None
                )


class CSVImportDriver(DataSourceDriver):
    """CSV import driver for bulk data import from legacy systems."""
    
    def __init__(self, data_source_id: int, file_path: str):
        self.data_source_id = data_source_id
        self.file_path = file_path
        self._connected = False
    
    def connect(self) -> bool:
        """Verify CSV file exists and is readable."""
        import os
        self._connected = os.path.exists(self.file_path)
        return self._connected
    
    def disconnect(self) -> None:
        """No connection to close for CSV."""
        self._connected = False
    
    def is_connected(self) -> bool:
        return self._connected
    
    def poll(self) -> Generator[MeasurementCreate, None, None]:
        """Parse CSV and yield normalized measurements."""
        import csv
        
        with open(self.file_path, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                try:
                    yield MeasurementCreate(
                        data_source_id=self.data_source_id,
                        meter_id=int(row.get("meter_id", 0)) or None,
                        timestamp=datetime.fromisoformat(row["timestamp"]),
                        value=float(row["value"]),
                        unit=row.get("unit", "kWh"),
                        quality=row.get("quality", "good"),
                        raw_value=float(row.get("raw_value", row["value"]))
                    )
                except (KeyError, ValueError):
                    continue


class DataNormalizer:
    """
    Service that normalizes data from all sources into standard Measurement format.
    
    Responsibilities:
    - Unit conversion (e.g., MWh to kWh)
    - Data quality validation
    - Timestamp normalization (timezone handling)
    - Outlier detection
    """
    
    UNIT_CONVERSIONS = {
        ("MWh", "kWh"): 1000.0,
        ("kWh", "MWh"): 0.001,
        ("MW", "kW"): 1000.0,
        ("kW", "MW"): 0.001,
        ("W", "kW"): 0.001,
        ("kW", "W"): 1000.0,
    }
    
    @classmethod
    def normalize_unit(cls, value: float, from_unit: str, to_unit: str) -> float:
        """Convert value between units."""
        if from_unit == to_unit:
            return value
        
        conversion_factor = cls.UNIT_CONVERSIONS.get((from_unit, to_unit))
        if conversion_factor:
            return value * conversion_factor
        
        return value
    
    @classmethod
    def validate_quality(cls, value: float, min_val: float = 0, max_val: float = 1e9) -> str:
        """Validate measurement quality based on value range."""
        if value < min_val or value > max_val:
            return "suspect"
        return "good"
    
    @classmethod
    def normalize_measurement(
        cls,
        measurement: MeasurementCreate,
        target_unit: str = "kWh"
    ) -> MeasurementCreate:
        """Normalize a measurement to standard format."""
        normalized_value = cls.normalize_unit(
            measurement.value,
            measurement.unit,
            target_unit
        )
        quality = cls.validate_quality(normalized_value)
        
        return MeasurementCreate(
            data_source_id=measurement.data_source_id,
            meter_id=measurement.meter_id,
            timestamp=measurement.timestamp,
            value=normalized_value,
            unit=target_unit,
            quality=quality,
            raw_value=measurement.raw_value
        )


# ============================================================================
# TENANT BILLING ENGINE (Enterprise Edition)
# ============================================================================

def calculate_tenant_monthly_bill(
    db,
    tenant_id: int,
    billing_period_start: date,
    billing_period_end: date,
    tax_rate: float = 0.0
) -> Invoice:
    """
    Calculate monthly bill for a tenant based on their lease contract and consumption.
    
    Algorithm:
    1. Get active lease contract for tenant
    2. Query meter readings for billing period
    3. Calculate line items:
       - Energy charge = consumption * rate_per_kwh
       - Demand charge = peak_demand * demand_charge_per_kw
       - Fixed fee = fixed_monthly_fee
       - Loss charge = energy_charge * loss_factor_percent
    4. Apply minimum monthly charge if applicable
    5. Calculate tax and total
    """
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise ValueError(f"Tenant {tenant_id} not found")
    
    lease = db.query(LeaseContract).filter(
        LeaseContract.tenant_id == tenant_id,
        LeaseContract.is_active == 1,
        LeaseContract.start_date <= billing_period_end,
        (LeaseContract.end_date.is_(None) | (LeaseContract.end_date >= billing_period_start))
    ).first()
    
    if not lease:
        raise ValueError(f"No active lease contract for tenant {tenant_id}")
    
    consumption_kwh = 0.0
    peak_demand_kw = 0.0
    
    if lease.meter_id:
        readings = db.query(MeterReading).filter(
            MeterReading.meter_id == lease.meter_id,
            MeterReading.reading_date >= billing_period_start,
            MeterReading.reading_date <= billing_period_end
        ).all()
        
        consumption_kwh = sum(r.energy_kwh for r in readings)
        peak_demand_kw = max((r.demand_kw for r in readings if r.demand_kw), default=0.0)
    
    energy_charge = consumption_kwh * lease.rate_per_kwh
    demand_charge = peak_demand_kw * lease.demand_charge_per_kw
    fixed_fee = lease.fixed_monthly_fee
    loss_charge = energy_charge * (lease.loss_factor_percent / 100.0)
    
    subtotal = energy_charge + demand_charge + fixed_fee + loss_charge
    
    if subtotal < lease.min_monthly_charge:
        subtotal = lease.min_monthly_charge
    
    tax_amount = subtotal * tax_rate
    total_amount = subtotal + tax_amount
    
    invoice_number = f"INV-{tenant_id}-{billing_period_start.strftime('%Y%m')}"
    
    invoice = Invoice(
        tenant_id=tenant_id,
        lease_contract_id=lease.id,
        invoice_number=invoice_number,
        billing_period_start=billing_period_start,
        billing_period_end=billing_period_end,
        consumption_kwh=consumption_kwh,
        peak_demand_kw=peak_demand_kw,
        energy_charge=energy_charge,
        demand_charge=demand_charge,
        fixed_fee=fixed_fee,
        loss_charge=loss_charge,
        subtotal=subtotal,
        tax_amount=tax_amount,
        total_amount=total_amount,
        status=InvoiceStatus.DRAFT,
        due_date=billing_period_end + timedelta(days=30)
    )
    
    db.add(invoice)
    db.commit()
    db.refresh(invoice)
    
    return invoice


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan events."""
    init_db()
    yield


app = FastAPI(
    title="SAVE-IT.AI",
    description="AI-driven energy management platform for B2B clients",
    version="0.1.0",
    lifespan=lifespan
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/")
def root():
    """Root endpoint."""
    return {
        "name": "SAVE-IT.AI",
        "version": "0.1.0",
        "description": "AI-driven energy management platform",
        "docs_url": "/docs",
        "api_prefix": "/api/v1"
    }


@app.get("/health")
def health_check():
    """Health check endpoint."""
    return {"status": "healthy"}


from fastapi import Depends, HTTPException, Query

@app.get("/api/v1/sites", response_model=List[SiteResponse], tags=["sites"])
def list_sites(skip: int = 0, limit: int = 100, db=Depends(get_db)):
    sites = db.query(Site).offset(skip).limit(limit).all()
    return sites


@app.get("/api/v1/sites/{site_id}", response_model=SiteResponse, tags=["sites"])
def get_site(site_id: int, db=Depends(get_db)):
    site = db.query(Site).filter(Site.id == site_id).first()
    if not site:
        raise HTTPException(status_code=404, detail="Site not found")
    return site


@app.post("/api/v1/sites", response_model=SiteResponse, tags=["sites"])
def create_site(site: SiteCreate, db=Depends(get_db)):
    db_site = Site(**site.model_dump())
    db.add(db_site)
    db.commit()
    db.refresh(db_site)
    return db_site


@app.put("/api/v1/sites/{site_id}", response_model=SiteResponse, tags=["sites"])
def update_site(site_id: int, site: SiteUpdate, db=Depends(get_db)):
    db_site = db.query(Site).filter(Site.id == site_id).first()
    if not db_site:
        raise HTTPException(status_code=404, detail="Site not found")
    update_data = site.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_site, field, value)
    db.commit()
    db.refresh(db_site)
    return db_site


@app.delete("/api/v1/sites/{site_id}", tags=["sites"])
def delete_site(site_id: int, db=Depends(get_db)):
    db_site = db.query(Site).filter(Site.id == site_id).first()
    if not db_site:
        raise HTTPException(status_code=404, detail="Site not found")
    db.delete(db_site)
    db.commit()
    return {"message": "Site deleted successfully"}


@app.get("/api/v1/assets", response_model=List[AssetResponse], tags=["assets"])
def list_assets(site_id: Optional[int] = None, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    query = db.query(Asset)
    if site_id:
        query = query.filter(Asset.site_id == site_id)
    return query.offset(skip).limit(limit).all()


@app.get("/api/v1/assets/tree/{site_id}", response_model=List[AssetTreeNode], tags=["assets"])
def get_asset_tree(site_id: int, db=Depends(get_db)):
    assets = db.query(Asset).filter(Asset.site_id == site_id).all()
    
    def build_tree(parent_id: Optional[int] = None) -> List[AssetTreeNode]:
        children = [a for a in assets if a.parent_id == parent_id]
        return [
            AssetTreeNode(
                id=asset.id,
                name=asset.name,
                asset_type=asset.asset_type,
                has_meter=asset.meter is not None,
                meter_id=asset.meter.meter_id if asset.meter else None,
                children=build_tree(asset.id)
            )
            for asset in children
        ]
    
    return build_tree(None)


@app.get("/api/v1/assets/{asset_id}", response_model=AssetResponse, tags=["assets"])
def get_asset(asset_id: int, db=Depends(get_db)):
    asset = db.query(Asset).filter(Asset.id == asset_id).first()
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    return asset


@app.post("/api/v1/assets", response_model=AssetResponse, tags=["assets"])
def create_asset(asset: AssetCreate, db=Depends(get_db)):
    db_asset = Asset(
        site_id=asset.site_id,
        parent_id=asset.parent_id,
        name=asset.name,
        asset_type=asset.asset_type,
        description=asset.description,
        rated_capacity_kw=asset.rated_capacity_kw,
        rated_voltage=asset.rated_voltage,
        rated_current=asset.rated_current,
        is_critical=1 if asset.is_critical else 0,
        requires_metering=1 if asset.requires_metering else 0
    )
    db.add(db_asset)
    db.commit()
    db.refresh(db_asset)
    return db_asset


@app.delete("/api/v1/assets/{asset_id}", tags=["assets"])
def delete_asset(asset_id: int, db=Depends(get_db)):
    db_asset = db.query(Asset).filter(Asset.id == asset_id).first()
    if not db_asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    db.delete(db_asset)
    db.commit()
    return {"message": "Asset deleted successfully"}


@app.get("/api/v1/meters", response_model=List[MeterResponse], tags=["meters"])
def list_meters(site_id: Optional[int] = None, active_only: bool = True, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    query = db.query(Meter)
    if site_id:
        query = query.filter(Meter.site_id == site_id)
    if active_only:
        query = query.filter(Meter.is_active == 1)
    return query.offset(skip).limit(limit).all()


@app.get("/api/v1/meters/{meter_id}", response_model=MeterResponse, tags=["meters"])
def get_meter(meter_id: int, db=Depends(get_db)):
    meter = db.query(Meter).filter(Meter.id == meter_id).first()
    if not meter:
        raise HTTPException(status_code=404, detail="Meter not found")
    return meter


@app.post("/api/v1/meters", response_model=MeterResponse, tags=["meters"])
def create_meter(meter: MeterCreate, db=Depends(get_db)):
    existing = db.query(Meter).filter(Meter.meter_id == meter.meter_id).first()
    if existing:
        raise HTTPException(status_code=400, detail="Meter ID already exists")
    db_meter = Meter(
        site_id=meter.site_id,
        asset_id=meter.asset_id,
        meter_id=meter.meter_id,
        name=meter.name,
        description=meter.description,
        manufacturer=meter.manufacturer,
        model=meter.model,
        serial_number=meter.serial_number,
        is_active=1 if meter.is_active else 0,
        is_bidirectional=1 if meter.is_bidirectional else 0
    )
    db.add(db_meter)
    db.commit()
    db.refresh(db_meter)
    return db_meter


@app.delete("/api/v1/meters/{meter_id}", tags=["meters"])
def delete_meter(meter_id: int, db=Depends(get_db)):
    db_meter = db.query(Meter).filter(Meter.id == meter_id).first()
    if not db_meter:
        raise HTTPException(status_code=404, detail="Meter not found")
    db.delete(db_meter)
    db.commit()
    return {"message": "Meter deleted successfully"}


@app.get("/api/v1/meters/{meter_id}/readings", response_model=List[MeterReadingResponse], tags=["meters"])
def get_meter_readings(
    meter_id: int,
    start_time: Optional[datetime] = Query(None),
    end_time: Optional[datetime] = Query(None),
    limit: int = 1000,
    db=Depends(get_db)
):
    meter = db.query(Meter).filter(Meter.id == meter_id).first()
    if not meter:
        raise HTTPException(status_code=404, detail="Meter not found")
    query = db.query(MeterReading).filter(MeterReading.meter_id == meter_id)
    if start_time:
        query = query.filter(MeterReading.timestamp >= start_time)
    if end_time:
        query = query.filter(MeterReading.timestamp <= end_time)
    return query.order_by(MeterReading.timestamp.desc()).limit(limit).all()


@app.post("/api/v1/meters/readings", response_model=MeterReadingResponse, tags=["meters"])
def create_meter_reading(reading: MeterReadingCreate, db=Depends(get_db)):
    meter = db.query(Meter).filter(Meter.id == reading.meter_id).first()
    if not meter:
        raise HTTPException(status_code=404, detail="Meter not found")
    db_reading = MeterReading(**reading.model_dump())
    db.add(db_reading)
    db.commit()
    db.refresh(db_reading)
    return db_reading


@app.get("/api/v1/bills", response_model=List[BillResponse], tags=["bills"])
def list_bills(site_id: Optional[int] = None, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    query = db.query(Bill)
    if site_id:
        query = query.filter(Bill.site_id == site_id)
    return query.order_by(Bill.period_start.desc()).offset(skip).limit(limit).all()


@app.get("/api/v1/bills/{bill_id}", response_model=BillResponse, tags=["bills"])
def get_bill(bill_id: int, db=Depends(get_db)):
    bill = db.query(Bill).filter(Bill.id == bill_id).first()
    if not bill:
        raise HTTPException(status_code=404, detail="Bill not found")
    return bill


@app.post("/api/v1/bills", response_model=BillResponse, tags=["bills"])
def create_bill(bill: BillCreate, db=Depends(get_db)):
    bill_data = bill.model_dump(exclude={'line_items'})
    db_bill = Bill(**bill_data)
    db.add(db_bill)
    db.commit()
    db.refresh(db_bill)
    for item in bill.line_items:
        db_item = BillLineItem(bill_id=db_bill.id, **item.model_dump())
        db.add(db_item)
    db.commit()
    db.refresh(db_bill)
    return db_bill


@app.post("/api/v1/bills/{bill_id}/validate", response_model=BillValidationResult, tags=["bills"])
def validate_bill_endpoint(bill_id: int, db=Depends(get_db)):
    try:
        return validate_bill(db, bill_id)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


@app.delete("/api/v1/bills/{bill_id}", tags=["bills"])
def delete_bill(bill_id: int, db=Depends(get_db)):
    db_bill = db.query(Bill).filter(Bill.id == bill_id).first()
    if not db_bill:
        raise HTTPException(status_code=404, detail="Bill not found")
    db.delete(db_bill)
    db.commit()
    return {"message": "Bill deleted successfully"}


@app.get("/api/v1/analysis/gap-analysis/{site_id}", response_model=GapAnalysisResult, tags=["analysis"])
def run_gap_analysis(site_id: int, db=Depends(get_db)):
    """Run gap analysis comparing SLD assets vs connected meters."""
    try:
        return perform_gap_analysis(db, site_id)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


@app.post("/api/v1/analysis/solar-roi", response_model=SolarROIResult, tags=["analysis"])
def calculate_solar_roi_endpoint(inputs: SolarROIInput):
    """Calculate solar PV system ROI with detailed financial projections."""
    return calculate_solar_roi(inputs)


# ============================================================================
# ENTERPRISE EDITION ENDPOINTS
# ============================================================================

@app.post("/api/v1/analysis/bess-simulation", response_model=BESSSimulationResult, tags=["analysis"])
def run_bess_simulation(inputs: BESSSimulationInput):
    """
    Run BESS financial simulation with TOU arbitrage and peak shaving analysis.
    
    Requires 8760 hourly values for load profile and tariff rates.
    Returns NPV, IRR, payback period, and monthly savings breakdown.
    """
    if len(inputs.load_profile_kwh) != 8760:
        raise HTTPException(
            status_code=400,
            detail=f"Load profile must have 8760 hourly values, got {len(inputs.load_profile_kwh)}"
        )
    if len(inputs.tariff_rates) != 8760:
        raise HTTPException(
            status_code=400,
            detail=f"Tariff rates must have 8760 hourly values, got {len(inputs.tariff_rates)}"
        )
    return simulate_bess_operation(inputs)


@app.post("/api/v1/tenants", response_model=TenantResponse, tags=["tenants"])
def create_tenant(tenant: TenantCreate, db=Depends(get_db)):
    """Create a new tenant for sub-billing."""
    db_tenant = Tenant(**tenant.model_dump())
    db.add(db_tenant)
    db.commit()
    db.refresh(db_tenant)
    return db_tenant


@app.get("/api/v1/tenants", response_model=List[TenantResponse], tags=["tenants"])
def list_tenants(site_id: Optional[int] = None, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    """List all tenants, optionally filtered by site."""
    query = db.query(Tenant)
    if site_id:
        query = query.filter(Tenant.site_id == site_id)
    return query.offset(skip).limit(limit).all()


@app.get("/api/v1/tenants/{tenant_id}", response_model=TenantResponse, tags=["tenants"])
def get_tenant(tenant_id: int, db=Depends(get_db)):
    """Get tenant by ID."""
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise HTTPException(status_code=404, detail="Tenant not found")
    return tenant


@app.post("/api/v1/lease-contracts", response_model=LeaseContractResponse, tags=["tenants"])
def create_lease_contract(contract: LeaseContractCreate, db=Depends(get_db)):
    """Create a new lease contract for a tenant."""
    db_contract = LeaseContract(**contract.model_dump())
    db.add(db_contract)
    db.commit()
    db.refresh(db_contract)
    return db_contract


@app.get("/api/v1/tenants/{tenant_id}/contracts", response_model=List[LeaseContractResponse], tags=["tenants"])
def list_tenant_contracts(tenant_id: int, db=Depends(get_db)):
    """List all lease contracts for a tenant."""
    return db.query(LeaseContract).filter(LeaseContract.tenant_id == tenant_id).all()


@app.post("/api/v1/tenants/{tenant_id}/generate-invoice", response_model=InvoiceResponse, tags=["billing"])
def generate_tenant_invoice(
    tenant_id: int,
    billing_start: date,
    billing_end: date,
    tax_rate: float = 0.0,
    db=Depends(get_db)
):
    """Generate a monthly invoice for a tenant."""
    try:
        return calculate_tenant_monthly_bill(db, tenant_id, billing_start, billing_end, tax_rate)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))


@app.get("/api/v1/invoices", response_model=List[InvoiceResponse], tags=["billing"])
def list_invoices(tenant_id: Optional[int] = None, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    """List all invoices, optionally filtered by tenant."""
    query = db.query(Invoice)
    if tenant_id:
        query = query.filter(Invoice.tenant_id == tenant_id)
    return query.order_by(Invoice.created_at.desc()).offset(skip).limit(limit).all()


@app.get("/api/v1/invoices/{invoice_id}", response_model=InvoiceResponse, tags=["billing"])
def get_invoice(invoice_id: int, db=Depends(get_db)):
    """Get invoice by ID."""
    invoice = db.query(Invoice).filter(Invoice.id == invoice_id).first()
    if not invoice:
        raise HTTPException(status_code=404, detail="Invoice not found")
    return invoice


@app.post("/api/v1/data-sources", response_model=DataSourceResponse, tags=["integrations"])
def create_data_source(source: DataSourceCreate, db=Depends(get_db)):
    """Create a new data source for meter integration."""
    db_source = DataSource(**source.model_dump())
    db.add(db_source)
    db.commit()
    db.refresh(db_source)
    return db_source


@app.get("/api/v1/data-sources", response_model=List[DataSourceResponse], tags=["integrations"])
def list_data_sources(site_id: Optional[int] = None, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    """List all data sources, optionally filtered by site."""
    query = db.query(DataSource)
    if site_id:
        query = query.filter(DataSource.site_id == site_id)
    return query.offset(skip).limit(limit).all()


@app.get("/api/v1/data-sources/{source_id}", response_model=DataSourceResponse, tags=["integrations"])
def get_data_source(source_id: int, db=Depends(get_db)):
    """Get data source by ID."""
    source = db.query(DataSource).filter(DataSource.id == source_id).first()
    if not source:
        raise HTTPException(status_code=404, detail="Data source not found")
    return source


@app.get("/api/v1/notifications", response_model=List[NotificationResponse], tags=["notifications"])
def list_notifications(site_id: Optional[int] = None, unread_only: bool = False, skip: int = 0, limit: int = 50, db=Depends(get_db)):
    query = db.query(Notification)
    if site_id:
        query = query.filter(Notification.site_id == site_id)
    if unread_only:
        query = query.filter(Notification.is_read == 0)
    return query.order_by(Notification.created_at.desc()).offset(skip).limit(limit).all()


@app.get("/api/v1/notifications/{notification_id}", response_model=NotificationResponse, tags=["notifications"])
def get_notification(notification_id: int, db=Depends(get_db)):
    notification = db.query(Notification).filter(Notification.id == notification_id).first()
    if not notification:
        raise HTTPException(status_code=404, detail="Notification not found")
    return notification


@app.post("/api/v1/notifications/{notification_id}/read", response_model=NotificationResponse, tags=["notifications"])
def mark_notification_read(notification_id: int, db=Depends(get_db)):
    notification = db.query(Notification).filter(Notification.id == notification_id).first()
    if not notification:
        raise HTTPException(status_code=404, detail="Notification not found")
    notification.is_read = 1
    db.commit()
    return notification


@app.post("/api/v1/notifications/{notification_id}/resolve", response_model=NotificationResponse, tags=["notifications"])
def mark_notification_resolved(notification_id: int, db=Depends(get_db)):
    notification = db.query(Notification).filter(Notification.id == notification_id).first()
    if not notification:
        raise HTTPException(status_code=404, detail="Notification not found")
    notification.is_resolved = 1
    notification.resolved_at = datetime.utcnow()
    db.commit()
    return notification


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=5000)
