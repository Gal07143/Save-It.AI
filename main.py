"""
SAVE-IT.AI - Main Entry Point

An AI-driven energy management platform that combines financial analysis
with electrical engineering (SLD/Digital Twin) to optimize energy usage
for B2B clients.
"""
import os
import sys

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = os.getenv("DATABASE_URL", "")

engine = create_engine(DATABASE_URL, pool_pre_ping=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()


def get_db():
    """Dependency to get database session."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


from datetime import datetime, date, time
from enum import Enum as PyEnum
from typing import List, Optional, Dict, Any
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Float, Enum, Text, Date, Time
from sqlalchemy.orm import relationship
from pydantic import BaseModel, Field


class AssetType(PyEnum):
    """Types of assets in the electrical hierarchy (SLD)."""
    MAIN_BREAKER = "main_breaker"
    SUB_PANEL = "sub_panel"
    DISTRIBUTION_BOARD = "distribution_board"
    CONSUMER = "consumer"
    TRANSFORMER = "transformer"
    GENERATOR = "generator"
    SOLAR_INVERTER = "solar_inverter"
    BATTERY_STORAGE = "battery_storage"


class NotificationType(PyEnum):
    """Types of notifications generated by AI agents."""
    MISSING_METER = "missing_meter"
    PEAK_SHAVING_ALERT = "peak_shaving_alert"
    BILL_VARIANCE = "bill_variance"
    ANOMALY_DETECTED = "anomaly_detected"
    SOLAR_ROI_UPDATE = "solar_roi_update"
    MAINTENANCE_REQUIRED = "maintenance_required"
    OPTIMIZATION_SUGGESTION = "optimization_suggestion"


class Site(Base):
    """Site model representing a physical facility or location."""
    __tablename__ = "sites"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False, index=True)
    address = Column(Text, nullable=True)
    city = Column(String(100), nullable=True)
    country = Column(String(100), nullable=True)
    latitude = Column(Float, nullable=True)
    longitude = Column(Float, nullable=True)
    timezone = Column(String(50), default="UTC")
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    assets = relationship("Asset", back_populates="site", cascade="all, delete-orphan")
    meters = relationship("Meter", back_populates="site", cascade="all, delete-orphan")
    bills = relationship("Bill", back_populates="site", cascade="all, delete-orphan")
    tariffs = relationship("Tariff", back_populates="site", cascade="all, delete-orphan")
    notifications = relationship("Notification", back_populates="site", cascade="all, delete-orphan")


class Asset(Base):
    """Asset model representing electrical components in the SLD hierarchy."""
    __tablename__ = "assets"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    parent_id = Column(Integer, ForeignKey("assets.id"), nullable=True, index=True)
    name = Column(String(255), nullable=False)
    asset_type = Column(Enum(AssetType), nullable=False)
    description = Column(Text, nullable=True)
    rated_capacity_kw = Column(Float, nullable=True)
    rated_voltage = Column(Float, nullable=True)
    rated_current = Column(Float, nullable=True)
    is_critical = Column(Integer, default=0)
    requires_metering = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    site = relationship("Site", back_populates="assets")
    parent = relationship("Asset", remote_side=[id], back_populates="children")
    children = relationship("Asset", back_populates="parent", cascade="all, delete-orphan")
    meter = relationship("Meter", back_populates="asset", uselist=False)


class Meter(Base):
    """Meter model representing a physical energy meter device."""
    __tablename__ = "meters"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    asset_id = Column(Integer, ForeignKey("assets.id"), nullable=True, index=True)
    meter_id = Column(String(100), unique=True, nullable=False, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    manufacturer = Column(String(100), nullable=True)
    model = Column(String(100), nullable=True)
    serial_number = Column(String(100), nullable=True)
    is_active = Column(Integer, default=1)
    is_bidirectional = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    site = relationship("Site", back_populates="meters")
    asset = relationship("Asset", back_populates="meter")
    readings = relationship("MeterReading", back_populates="meter", cascade="all, delete-orphan")


class MeterReading(Base):
    """MeterReading model for time-series energy data."""
    __tablename__ = "meter_readings"

    id = Column(Integer, primary_key=True, index=True)
    meter_id = Column(Integer, ForeignKey("meters.id"), nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    energy_kwh = Column(Float, nullable=False)
    power_kw = Column(Float, nullable=True)
    voltage = Column(Float, nullable=True)
    current = Column(Float, nullable=True)
    power_factor = Column(Float, nullable=True)
    reactive_power_kvar = Column(Float, nullable=True)
    apparent_power_kva = Column(Float, nullable=True)
    reading_type = Column(String(50), default="interval")
    created_at = Column(DateTime, default=datetime.utcnow)

    meter = relationship("Meter", back_populates="readings")


class Bill(Base):
    """Bill model representing a utility bill for a site."""
    __tablename__ = "bills"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    tariff_id = Column(Integer, ForeignKey("tariffs.id"), nullable=True, index=True)
    bill_number = Column(String(100), nullable=True, index=True)
    provider_name = Column(String(255), nullable=True)
    period_start = Column(Date, nullable=False)
    period_end = Column(Date, nullable=False)
    issue_date = Column(Date, nullable=True)
    due_date = Column(Date, nullable=True)
    total_kwh = Column(Float, nullable=False)
    total_amount = Column(Float, nullable=False)
    currency = Column(String(10), default="USD")
    peak_kwh = Column(Float, nullable=True)
    off_peak_kwh = Column(Float, nullable=True)
    demand_kw = Column(Float, nullable=True)
    power_factor_penalty = Column(Float, nullable=True)
    taxes = Column(Float, nullable=True)
    other_charges = Column(Float, nullable=True)
    notes = Column(Text, nullable=True)
    is_validated = Column(Integer, default=0)
    validation_variance_pct = Column(Float, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    site = relationship("Site", back_populates="bills")
    tariff = relationship("Tariff", back_populates="bills")
    line_items = relationship("BillLineItem", back_populates="bill", cascade="all, delete-orphan")


class BillLineItem(Base):
    """BillLineItem model for detailed bill breakdown."""
    __tablename__ = "bill_line_items"

    id = Column(Integer, primary_key=True, index=True)
    bill_id = Column(Integer, ForeignKey("bills.id"), nullable=False, index=True)
    description = Column(String(255), nullable=False)
    category = Column(String(100), nullable=True)
    quantity = Column(Float, nullable=True)
    unit = Column(String(50), nullable=True)
    unit_price = Column(Float, nullable=True)
    amount = Column(Float, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    bill = relationship("Bill", back_populates="line_items")


class Tariff(Base):
    """Tariff model representing a utility pricing structure."""
    __tablename__ = "tariffs"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    provider_name = Column(String(255), nullable=True)
    effective_from = Column(DateTime, nullable=True)
    effective_to = Column(DateTime, nullable=True)
    currency = Column(String(10), default="USD")
    fixed_charge = Column(Float, default=0.0)
    demand_charge_per_kw = Column(Float, nullable=True)
    power_factor_threshold = Column(Float, nullable=True)
    power_factor_penalty_rate = Column(Float, nullable=True)
    is_active = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    site = relationship("Site", back_populates="tariffs")
    rates = relationship("TariffRate", back_populates="tariff", cascade="all, delete-orphan")
    bills = relationship("Bill", back_populates="tariff")


class TariffRate(Base):
    """TariffRate model for time-of-use pricing periods."""
    __tablename__ = "tariff_rates"

    id = Column(Integer, primary_key=True, index=True)
    tariff_id = Column(Integer, ForeignKey("tariffs.id"), nullable=False, index=True)
    name = Column(String(100), nullable=False)
    rate_per_kwh = Column(Float, nullable=False)
    time_start = Column(Time, nullable=True)
    time_end = Column(Time, nullable=True)
    days_of_week = Column(String(50), nullable=True)
    season = Column(String(50), nullable=True)
    tier_min_kwh = Column(Float, nullable=True)
    tier_max_kwh = Column(Float, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    tariff = relationship("Tariff", back_populates="rates")


class Notification(Base):
    """Notification model for AI-generated alerts."""
    __tablename__ = "notifications"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    asset_id = Column(Integer, ForeignKey("assets.id"), nullable=True, index=True)
    notification_type = Column(Enum(NotificationType), nullable=False)
    severity = Column(String(20), default="info")
    title = Column(String(255), nullable=False)
    message = Column(Text, nullable=False)
    is_read = Column(Integer, default=0)
    is_resolved = Column(Integer, default=0)
    agent_name = Column(String(100), nullable=True)
    extra_data = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    resolved_at = Column(DateTime, nullable=True)

    site = relationship("Site", back_populates="notifications")


class SiteCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=255)
    address: Optional[str] = None
    city: Optional[str] = None
    country: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    timezone: str = "UTC"


class SiteUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    address: Optional[str] = None
    city: Optional[str] = None
    country: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    timezone: Optional[str] = None


class SiteResponse(BaseModel):
    id: int
    name: str
    address: Optional[str] = None
    city: Optional[str] = None
    country: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    timezone: str
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


class AssetCreate(BaseModel):
    site_id: int
    parent_id: Optional[int] = None
    name: str = Field(..., min_length=1, max_length=255)
    asset_type: AssetType
    description: Optional[str] = None
    rated_capacity_kw: Optional[float] = None
    rated_voltage: Optional[float] = None
    rated_current: Optional[float] = None
    is_critical: bool = False
    requires_metering: bool = True


class AssetUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    asset_type: Optional[AssetType] = None
    description: Optional[str] = None
    parent_id: Optional[int] = None
    rated_capacity_kw: Optional[float] = None
    rated_voltage: Optional[float] = None
    rated_current: Optional[float] = None
    is_critical: Optional[bool] = None
    requires_metering: Optional[bool] = None


class AssetResponse(BaseModel):
    id: int
    site_id: int
    parent_id: Optional[int] = None
    name: str
    asset_type: AssetType
    description: Optional[str] = None
    rated_capacity_kw: Optional[float] = None
    rated_voltage: Optional[float] = None
    rated_current: Optional[float] = None
    is_critical: bool = False
    requires_metering: bool = True
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


class AssetTreeNode(BaseModel):
    id: int
    name: str
    asset_type: AssetType
    has_meter: bool = False
    meter_id: Optional[str] = None
    children: List["AssetTreeNode"] = []

    class Config:
        from_attributes = True


AssetTreeNode.model_rebuild()


class MeterCreate(BaseModel):
    site_id: int
    asset_id: Optional[int] = None
    meter_id: str = Field(..., min_length=1, max_length=100)
    name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    manufacturer: Optional[str] = None
    model: Optional[str] = None
    serial_number: Optional[str] = None
    is_active: bool = True
    is_bidirectional: bool = False


class MeterUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    description: Optional[str] = None
    asset_id: Optional[int] = None
    manufacturer: Optional[str] = None
    model: Optional[str] = None
    serial_number: Optional[str] = None
    is_active: Optional[bool] = None
    is_bidirectional: Optional[bool] = None


class MeterResponse(BaseModel):
    id: int
    site_id: int
    asset_id: Optional[int] = None
    meter_id: str
    name: str
    description: Optional[str] = None
    manufacturer: Optional[str] = None
    model: Optional[str] = None
    serial_number: Optional[str] = None
    is_active: bool
    is_bidirectional: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


class MeterReadingCreate(BaseModel):
    meter_id: int
    timestamp: datetime
    energy_kwh: float
    power_kw: Optional[float] = None
    voltage: Optional[float] = None
    current: Optional[float] = None
    power_factor: Optional[float] = None
    reactive_power_kvar: Optional[float] = None
    apparent_power_kva: Optional[float] = None
    reading_type: str = "interval"


class MeterReadingResponse(BaseModel):
    id: int
    meter_id: int
    timestamp: datetime
    energy_kwh: float
    power_kw: Optional[float] = None
    voltage: Optional[float] = None
    current: Optional[float] = None
    power_factor: Optional[float] = None
    reactive_power_kvar: Optional[float] = None
    apparent_power_kva: Optional[float] = None
    reading_type: str
    created_at: datetime

    class Config:
        from_attributes = True


class BillLineItemCreate(BaseModel):
    description: str
    category: Optional[str] = None
    quantity: Optional[float] = None
    unit: Optional[str] = None
    unit_price: Optional[float] = None
    amount: float


class BillLineItemResponse(BaseModel):
    id: int
    bill_id: int
    description: str
    category: Optional[str] = None
    quantity: Optional[float] = None
    unit: Optional[str] = None
    unit_price: Optional[float] = None
    amount: float
    created_at: datetime

    class Config:
        from_attributes = True


class BillCreate(BaseModel):
    site_id: int
    tariff_id: Optional[int] = None
    bill_number: Optional[str] = None
    provider_name: Optional[str] = None
    period_start: date
    period_end: date
    issue_date: Optional[date] = None
    due_date: Optional[date] = None
    total_kwh: float
    total_amount: float
    currency: str = "USD"
    peak_kwh: Optional[float] = None
    off_peak_kwh: Optional[float] = None
    demand_kw: Optional[float] = None
    power_factor_penalty: Optional[float] = None
    taxes: Optional[float] = None
    other_charges: Optional[float] = None
    notes: Optional[str] = None
    line_items: List[BillLineItemCreate] = []


class BillUpdate(BaseModel):
    bill_number: Optional[str] = None
    provider_name: Optional[str] = None
    period_start: Optional[date] = None
    period_end: Optional[date] = None
    issue_date: Optional[date] = None
    due_date: Optional[date] = None
    total_kwh: Optional[float] = None
    total_amount: Optional[float] = None
    currency: Optional[str] = None
    tariff_id: Optional[int] = None
    notes: Optional[str] = None


class BillResponse(BaseModel):
    id: int
    site_id: int
    tariff_id: Optional[int] = None
    bill_number: Optional[str] = None
    provider_name: Optional[str] = None
    period_start: date
    period_end: date
    issue_date: Optional[date] = None
    due_date: Optional[date] = None
    total_kwh: float
    total_amount: float
    currency: str
    peak_kwh: Optional[float] = None
    off_peak_kwh: Optional[float] = None
    demand_kw: Optional[float] = None
    power_factor_penalty: Optional[float] = None
    taxes: Optional[float] = None
    other_charges: Optional[float] = None
    notes: Optional[str] = None
    is_validated: bool
    validation_variance_pct: Optional[float] = None
    created_at: datetime
    updated_at: datetime
    line_items: List[BillLineItemResponse] = []

    class Config:
        from_attributes = True


class BillValidationResult(BaseModel):
    bill_id: int
    is_valid: bool
    bill_total_kwh: float
    meter_total_kwh: float
    variance_kwh: float
    variance_percentage: float
    message: str


class UnmeteredAsset(BaseModel):
    asset_id: int
    asset_name: str
    asset_type: AssetType
    parent_id: Optional[int] = None
    parent_name: Optional[str] = None
    rated_capacity_kw: Optional[float] = None
    is_critical: bool = False
    hierarchy_path: List[str] = []


class GapAnalysisResult(BaseModel):
    site_id: int
    site_name: str
    total_assets: int
    metered_assets: int
    unmetered_assets: int
    coverage_percentage: float
    critical_unmetered_count: int
    unmetered_asset_list: List[UnmeteredAsset] = []
    recommendations: List[str] = []


class NotificationResponse(BaseModel):
    id: int
    site_id: int
    asset_id: Optional[int] = None
    notification_type: NotificationType
    severity: str
    title: str
    message: str
    is_read: bool
    is_resolved: bool
    agent_name: Optional[str] = None
    extra_data: Optional[str] = None
    created_at: datetime
    resolved_at: Optional[datetime] = None

    class Config:
        from_attributes = True


class SolarROIInput(BaseModel):
    """Input parameters for Solar ROI calculation."""
    annual_consumption_kwh: float
    average_electricity_rate: float
    system_size_kw: float
    installation_cost: float
    annual_solar_production_kwh_per_kw: float = 1400
    annual_degradation_rate: float = 0.005
    maintenance_cost_annual: float = 0.0
    incentive_amount: float = 0.0
    net_metering_rate: Optional[float] = None
    analysis_period_years: int = 25
    inflation_rate: float = 0.03


class SolarROIResult(BaseModel):
    """Result of Solar ROI calculation."""
    system_size_kw: float
    installation_cost: float
    year_one_production_kwh: float
    year_one_savings: float
    simple_payback_years: float
    net_present_value: float
    internal_rate_of_return: float
    lifetime_savings: float
    break_even_year: Optional[int]
    annual_projections: List[dict]


def init_db():
    """Initialize database tables."""
    Base.metadata.create_all(bind=engine)


def perform_gap_analysis(db, site_id: int) -> GapAnalysisResult:
    """
    Perform gap analysis for a given site.
    
    Compares the SLD asset tree with connected meters to identify
    unmetered nodes that require monitoring.
    
    Algorithm:
    1. Get all assets for the site
    2. Get all active meters for the site
    3. Find assets that require metering but have no meter
    4. Generate recommendations
    """
    site = db.query(Site).filter(Site.id == site_id).first()
    if not site:
        raise ValueError(f"Site with ID {site_id} not found")

    assets = db.query(Asset).filter(Asset.site_id == site_id).all()
    active_meters = db.query(Meter).filter(
        Meter.site_id == site_id,
        Meter.is_active == 1
    ).all()
    
    metered_asset_ids = {
        meter.asset_id for meter in active_meters if meter.asset_id is not None
    }

    asset_dict = {asset.id: asset for asset in assets}
    assets_requiring_metering = [a for a in assets if a.requires_metering]
    
    unmetered_assets: List[UnmeteredAsset] = []
    critical_unmetered_count = 0

    for asset in assets_requiring_metering:
        if asset.id not in metered_asset_ids:
            path = []
            current = asset
            while current:
                path.insert(0, current.name)
                if current.parent_id:
                    current = asset_dict.get(current.parent_id)
                else:
                    break

            parent_name = None
            if asset.parent_id:
                parent = asset_dict.get(asset.parent_id)
                parent_name = parent.name if parent else None

            unmetered_asset = UnmeteredAsset(
                asset_id=asset.id,
                asset_name=asset.name,
                asset_type=asset.asset_type,
                parent_id=asset.parent_id,
                parent_name=parent_name,
                rated_capacity_kw=asset.rated_capacity_kw,
                is_critical=bool(asset.is_critical),
                hierarchy_path=path
            )
            unmetered_assets.append(unmetered_asset)
            if asset.is_critical:
                critical_unmetered_count += 1

    total_requiring_metering = len(assets_requiring_metering)
    metered_count = total_requiring_metering - len(unmetered_assets)
    coverage_percentage = (
        (metered_count / total_requiring_metering * 100)
        if total_requiring_metering > 0 else 100.0
    )

    recommendations = []
    if critical_unmetered_count > 0:
        recommendations.append(
            f"CRITICAL: {critical_unmetered_count} critical asset(s) are unmetered."
        )
    if coverage_percentage < 50:
        recommendations.append(f"Coverage is very low ({coverage_percentage:.1f}%).")
    elif coverage_percentage < 80:
        recommendations.append(f"Coverage is moderate ({coverage_percentage:.1f}%).")

    return GapAnalysisResult(
        site_id=site_id,
        site_name=site.name,
        total_assets=len(assets),
        metered_assets=metered_count,
        unmetered_assets=len(unmetered_assets),
        coverage_percentage=round(coverage_percentage, 2),
        critical_unmetered_count=critical_unmetered_count,
        unmetered_asset_list=unmetered_assets,
        recommendations=recommendations
    )


def validate_bill(db, bill_id: int) -> BillValidationResult:
    """
    Validate a bill by comparing with meter readings.
    
    Cross-references the bill's total kWh with the sum of
    meter readings for the same period.
    """
    bill = db.query(Bill).filter(Bill.id == bill_id).first()
    if not bill:
        raise ValueError(f"Bill with ID {bill_id} not found")

    period_start = datetime.combine(bill.period_start, datetime.min.time())
    period_end = datetime.combine(bill.period_end, datetime.max.time())

    meters = db.query(Meter).filter(
        Meter.site_id == bill.site_id,
        Meter.is_active == 1
    ).all()

    meter_total_kwh = 0.0
    for meter in meters:
        readings = db.query(MeterReading).filter(
            MeterReading.meter_id == meter.id,
            MeterReading.timestamp >= period_start,
            MeterReading.timestamp <= period_end
        ).all()
        if readings:
            meter_total_kwh += sum(r.energy_kwh for r in readings)

    variance_kwh = bill.total_kwh - meter_total_kwh
    variance_percentage = (
        (variance_kwh / bill.total_kwh * 100) if bill.total_kwh > 0 else 0.0
    )

    is_valid = abs(variance_percentage) <= 2.0

    if is_valid:
        message = f"Bill validated. Variance of {variance_percentage:.2f}% is within tolerance."
    elif abs(variance_percentage) <= 5.0:
        message = f"Minor variance detected ({variance_percentage:.2f}%)."
    else:
        message = f"Significant variance detected ({variance_percentage:.2f}%)."

    bill.is_validated = 1 if is_valid else 0
    bill.validation_variance_pct = variance_percentage
    db.commit()

    return BillValidationResult(
        bill_id=bill_id,
        is_valid=is_valid,
        bill_total_kwh=bill.total_kwh,
        meter_total_kwh=meter_total_kwh,
        variance_kwh=variance_kwh,
        variance_percentage=round(variance_percentage, 2),
        message=message
    )


def calculate_solar_roi(inputs: SolarROIInput) -> SolarROIResult:
    """
    Calculate solar PV system ROI.
    
    Formulas:
    - Year N Production = System Size * kWh/kW * (1 - degradation_rate)^(N-1)
    - Year N Savings = Production_N * Rate * (1 + inflation)^(N-1)
    - Simple Payback = Net Cost / Year 1 Savings
    - NPV = Sum of discounted cash flows
    - IRR = Discount rate that makes NPV = 0
    """
    net_cost = inputs.installation_cost - inputs.incentive_amount
    year_one_production = inputs.system_size_kw * inputs.annual_solar_production_kwh_per_kw
    export_rate = inputs.net_metering_rate or inputs.average_electricity_rate
    discount_rate = 0.06

    annual_projections = []
    cumulative_savings = 0.0
    cumulative_cash_flow = -net_cost
    break_even_year = None

    for year in range(1, inputs.analysis_period_years + 1):
        degradation_factor = (1 - inputs.annual_degradation_rate) ** (year - 1)
        production = year_one_production * degradation_factor
        inflation_factor = (1 + inputs.inflation_rate) ** (year - 1)
        current_rate = inputs.average_electricity_rate * inflation_factor
        
        self_consumption = min(production, inputs.annual_consumption_kwh * degradation_factor)
        export = max(0, production - self_consumption)
        savings = (self_consumption * current_rate) + (export * export_rate * inflation_factor)
        net_annual = savings - inputs.maintenance_cost_annual
        
        cumulative_savings += net_annual
        cumulative_cash_flow += net_annual

        if break_even_year is None and cumulative_cash_flow >= 0:
            break_even_year = year

        annual_projections.append({
            "year": year,
            "production_kwh": round(production, 2),
            "savings": round(net_annual, 2),
            "cumulative_savings": round(cumulative_savings, 2),
            "cumulative_cash_flow": round(cumulative_cash_flow, 2)
        })

    year_one_savings = annual_projections[0]["savings"]
    simple_payback = net_cost / year_one_savings if year_one_savings > 0 else float('inf')

    npv = -net_cost
    for proj in annual_projections:
        npv += proj["savings"] / ((1 + discount_rate) ** proj["year"])

    cash_flows = [-net_cost] + [p["savings"] for p in annual_projections]
    rate = 0.1
    for _ in range(100):
        npv_val = sum(cf / ((1 + rate) ** i) for i, cf in enumerate(cash_flows))
        npv_derivative = sum(-i * cf / ((1 + rate) ** (i + 1)) for i, cf in enumerate(cash_flows))
        if abs(npv_derivative) < 1e-10:
            break
        new_rate = rate - npv_val / npv_derivative
        if abs(new_rate - rate) < 1e-6:
            break
        rate = max(-0.99, min(new_rate, 10))
    irr = rate

    return SolarROIResult(
        system_size_kw=inputs.system_size_kw,
        installation_cost=inputs.installation_cost,
        year_one_production_kwh=round(year_one_production, 2),
        year_one_savings=round(year_one_savings, 2),
        simple_payback_years=round(simple_payback, 2),
        net_present_value=round(npv, 2),
        internal_rate_of_return=round(irr * 100, 2),
        lifetime_savings=round(cumulative_savings, 2),
        break_even_year=break_even_year,
        annual_projections=annual_projections
    )


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan events."""
    init_db()
    yield


app = FastAPI(
    title="SAVE-IT.AI",
    description="AI-driven energy management platform for B2B clients",
    version="0.1.0",
    lifespan=lifespan
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/")
def root():
    """Root endpoint."""
    return {
        "name": "SAVE-IT.AI",
        "version": "0.1.0",
        "description": "AI-driven energy management platform",
        "docs_url": "/docs",
        "api_prefix": "/api/v1"
    }


@app.get("/health")
def health_check():
    """Health check endpoint."""
    return {"status": "healthy"}


from fastapi import Depends, HTTPException, Query

@app.get("/api/v1/sites", response_model=List[SiteResponse], tags=["sites"])
def list_sites(skip: int = 0, limit: int = 100, db=Depends(get_db)):
    sites = db.query(Site).offset(skip).limit(limit).all()
    return sites


@app.get("/api/v1/sites/{site_id}", response_model=SiteResponse, tags=["sites"])
def get_site(site_id: int, db=Depends(get_db)):
    site = db.query(Site).filter(Site.id == site_id).first()
    if not site:
        raise HTTPException(status_code=404, detail="Site not found")
    return site


@app.post("/api/v1/sites", response_model=SiteResponse, tags=["sites"])
def create_site(site: SiteCreate, db=Depends(get_db)):
    db_site = Site(**site.model_dump())
    db.add(db_site)
    db.commit()
    db.refresh(db_site)
    return db_site


@app.put("/api/v1/sites/{site_id}", response_model=SiteResponse, tags=["sites"])
def update_site(site_id: int, site: SiteUpdate, db=Depends(get_db)):
    db_site = db.query(Site).filter(Site.id == site_id).first()
    if not db_site:
        raise HTTPException(status_code=404, detail="Site not found")
    update_data = site.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_site, field, value)
    db.commit()
    db.refresh(db_site)
    return db_site


@app.delete("/api/v1/sites/{site_id}", tags=["sites"])
def delete_site(site_id: int, db=Depends(get_db)):
    db_site = db.query(Site).filter(Site.id == site_id).first()
    if not db_site:
        raise HTTPException(status_code=404, detail="Site not found")
    db.delete(db_site)
    db.commit()
    return {"message": "Site deleted successfully"}


@app.get("/api/v1/assets", response_model=List[AssetResponse], tags=["assets"])
def list_assets(site_id: Optional[int] = None, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    query = db.query(Asset)
    if site_id:
        query = query.filter(Asset.site_id == site_id)
    return query.offset(skip).limit(limit).all()


@app.get("/api/v1/assets/tree/{site_id}", response_model=List[AssetTreeNode], tags=["assets"])
def get_asset_tree(site_id: int, db=Depends(get_db)):
    assets = db.query(Asset).filter(Asset.site_id == site_id).all()
    
    def build_tree(parent_id: Optional[int] = None) -> List[AssetTreeNode]:
        children = [a for a in assets if a.parent_id == parent_id]
        return [
            AssetTreeNode(
                id=asset.id,
                name=asset.name,
                asset_type=asset.asset_type,
                has_meter=asset.meter is not None,
                meter_id=asset.meter.meter_id if asset.meter else None,
                children=build_tree(asset.id)
            )
            for asset in children
        ]
    
    return build_tree(None)


@app.get("/api/v1/assets/{asset_id}", response_model=AssetResponse, tags=["assets"])
def get_asset(asset_id: int, db=Depends(get_db)):
    asset = db.query(Asset).filter(Asset.id == asset_id).first()
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    return asset


@app.post("/api/v1/assets", response_model=AssetResponse, tags=["assets"])
def create_asset(asset: AssetCreate, db=Depends(get_db)):
    db_asset = Asset(
        site_id=asset.site_id,
        parent_id=asset.parent_id,
        name=asset.name,
        asset_type=asset.asset_type,
        description=asset.description,
        rated_capacity_kw=asset.rated_capacity_kw,
        rated_voltage=asset.rated_voltage,
        rated_current=asset.rated_current,
        is_critical=1 if asset.is_critical else 0,
        requires_metering=1 if asset.requires_metering else 0
    )
    db.add(db_asset)
    db.commit()
    db.refresh(db_asset)
    return db_asset


@app.delete("/api/v1/assets/{asset_id}", tags=["assets"])
def delete_asset(asset_id: int, db=Depends(get_db)):
    db_asset = db.query(Asset).filter(Asset.id == asset_id).first()
    if not db_asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    db.delete(db_asset)
    db.commit()
    return {"message": "Asset deleted successfully"}


@app.get("/api/v1/meters", response_model=List[MeterResponse], tags=["meters"])
def list_meters(site_id: Optional[int] = None, active_only: bool = True, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    query = db.query(Meter)
    if site_id:
        query = query.filter(Meter.site_id == site_id)
    if active_only:
        query = query.filter(Meter.is_active == 1)
    return query.offset(skip).limit(limit).all()


@app.get("/api/v1/meters/{meter_id}", response_model=MeterResponse, tags=["meters"])
def get_meter(meter_id: int, db=Depends(get_db)):
    meter = db.query(Meter).filter(Meter.id == meter_id).first()
    if not meter:
        raise HTTPException(status_code=404, detail="Meter not found")
    return meter


@app.post("/api/v1/meters", response_model=MeterResponse, tags=["meters"])
def create_meter(meter: MeterCreate, db=Depends(get_db)):
    existing = db.query(Meter).filter(Meter.meter_id == meter.meter_id).first()
    if existing:
        raise HTTPException(status_code=400, detail="Meter ID already exists")
    db_meter = Meter(
        site_id=meter.site_id,
        asset_id=meter.asset_id,
        meter_id=meter.meter_id,
        name=meter.name,
        description=meter.description,
        manufacturer=meter.manufacturer,
        model=meter.model,
        serial_number=meter.serial_number,
        is_active=1 if meter.is_active else 0,
        is_bidirectional=1 if meter.is_bidirectional else 0
    )
    db.add(db_meter)
    db.commit()
    db.refresh(db_meter)
    return db_meter


@app.delete("/api/v1/meters/{meter_id}", tags=["meters"])
def delete_meter(meter_id: int, db=Depends(get_db)):
    db_meter = db.query(Meter).filter(Meter.id == meter_id).first()
    if not db_meter:
        raise HTTPException(status_code=404, detail="Meter not found")
    db.delete(db_meter)
    db.commit()
    return {"message": "Meter deleted successfully"}


@app.get("/api/v1/meters/{meter_id}/readings", response_model=List[MeterReadingResponse], tags=["meters"])
def get_meter_readings(
    meter_id: int,
    start_time: Optional[datetime] = Query(None),
    end_time: Optional[datetime] = Query(None),
    limit: int = 1000,
    db=Depends(get_db)
):
    meter = db.query(Meter).filter(Meter.id == meter_id).first()
    if not meter:
        raise HTTPException(status_code=404, detail="Meter not found")
    query = db.query(MeterReading).filter(MeterReading.meter_id == meter_id)
    if start_time:
        query = query.filter(MeterReading.timestamp >= start_time)
    if end_time:
        query = query.filter(MeterReading.timestamp <= end_time)
    return query.order_by(MeterReading.timestamp.desc()).limit(limit).all()


@app.post("/api/v1/meters/readings", response_model=MeterReadingResponse, tags=["meters"])
def create_meter_reading(reading: MeterReadingCreate, db=Depends(get_db)):
    meter = db.query(Meter).filter(Meter.id == reading.meter_id).first()
    if not meter:
        raise HTTPException(status_code=404, detail="Meter not found")
    db_reading = MeterReading(**reading.model_dump())
    db.add(db_reading)
    db.commit()
    db.refresh(db_reading)
    return db_reading


@app.get("/api/v1/bills", response_model=List[BillResponse], tags=["bills"])
def list_bills(site_id: Optional[int] = None, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    query = db.query(Bill)
    if site_id:
        query = query.filter(Bill.site_id == site_id)
    return query.order_by(Bill.period_start.desc()).offset(skip).limit(limit).all()


@app.get("/api/v1/bills/{bill_id}", response_model=BillResponse, tags=["bills"])
def get_bill(bill_id: int, db=Depends(get_db)):
    bill = db.query(Bill).filter(Bill.id == bill_id).first()
    if not bill:
        raise HTTPException(status_code=404, detail="Bill not found")
    return bill


@app.post("/api/v1/bills", response_model=BillResponse, tags=["bills"])
def create_bill(bill: BillCreate, db=Depends(get_db)):
    bill_data = bill.model_dump(exclude={'line_items'})
    db_bill = Bill(**bill_data)
    db.add(db_bill)
    db.commit()
    db.refresh(db_bill)
    for item in bill.line_items:
        db_item = BillLineItem(bill_id=db_bill.id, **item.model_dump())
        db.add(db_item)
    db.commit()
    db.refresh(db_bill)
    return db_bill


@app.post("/api/v1/bills/{bill_id}/validate", response_model=BillValidationResult, tags=["bills"])
def validate_bill_endpoint(bill_id: int, db=Depends(get_db)):
    try:
        return validate_bill(db, bill_id)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


@app.delete("/api/v1/bills/{bill_id}", tags=["bills"])
def delete_bill(bill_id: int, db=Depends(get_db)):
    db_bill = db.query(Bill).filter(Bill.id == bill_id).first()
    if not db_bill:
        raise HTTPException(status_code=404, detail="Bill not found")
    db.delete(db_bill)
    db.commit()
    return {"message": "Bill deleted successfully"}


@app.get("/api/v1/analysis/gap-analysis/{site_id}", response_model=GapAnalysisResult, tags=["analysis"])
def run_gap_analysis(site_id: int, db=Depends(get_db)):
    """Run gap analysis comparing SLD assets vs connected meters."""
    try:
        return perform_gap_analysis(db, site_id)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


@app.post("/api/v1/analysis/solar-roi", response_model=SolarROIResult, tags=["analysis"])
def calculate_solar_roi_endpoint(inputs: SolarROIInput):
    """Calculate solar PV system ROI with detailed financial projections."""
    return calculate_solar_roi(inputs)


@app.get("/api/v1/notifications", response_model=List[NotificationResponse], tags=["notifications"])
def list_notifications(site_id: Optional[int] = None, unread_only: bool = False, skip: int = 0, limit: int = 50, db=Depends(get_db)):
    query = db.query(Notification)
    if site_id:
        query = query.filter(Notification.site_id == site_id)
    if unread_only:
        query = query.filter(Notification.is_read == 0)
    return query.order_by(Notification.created_at.desc()).offset(skip).limit(limit).all()


@app.get("/api/v1/notifications/{notification_id}", response_model=NotificationResponse, tags=["notifications"])
def get_notification(notification_id: int, db=Depends(get_db)):
    notification = db.query(Notification).filter(Notification.id == notification_id).first()
    if not notification:
        raise HTTPException(status_code=404, detail="Notification not found")
    return notification


@app.post("/api/v1/notifications/{notification_id}/read", response_model=NotificationResponse, tags=["notifications"])
def mark_notification_read(notification_id: int, db=Depends(get_db)):
    notification = db.query(Notification).filter(Notification.id == notification_id).first()
    if not notification:
        raise HTTPException(status_code=404, detail="Notification not found")
    notification.is_read = 1
    db.commit()
    return notification


@app.post("/api/v1/notifications/{notification_id}/resolve", response_model=NotificationResponse, tags=["notifications"])
def mark_notification_resolved(notification_id: int, db=Depends(get_db)):
    notification = db.query(Notification).filter(Notification.id == notification_id).first()
    if not notification:
        raise HTTPException(status_code=404, detail="Notification not found")
    notification.is_resolved = 1
    notification.resolved_at = datetime.utcnow()
    db.commit()
    return notification


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=5000)
