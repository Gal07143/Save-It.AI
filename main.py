"""
SAVE-IT.AI - Main Entry Point

An AI-driven energy management platform that combines financial analysis
with electrical engineering (SLD/Digital Twin) to optimize energy usage
for B2B clients.
"""
import os
import sys
import secrets

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from fastapi import FastAPI, Depends, HTTPException, status, UploadFile, File, Form, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from contextlib import asynccontextmanager
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
import bcrypt
from jose import JWTError, jwt

DATABASE_URL = os.getenv("DATABASE_URL", "")

engine = create_engine(DATABASE_URL, pool_pre_ping=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()


def get_db():
    """Dependency to get database session."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


from datetime import datetime, date, time, timedelta
from typing import Optional, List, Dict, Any
from enum import Enum as PyEnum


# ============================================================================
# AUTHENTICATION CONFIGURATION
# ============================================================================

SECRET_KEY = os.getenv("SESSION_SECRET", secrets.token_urlsafe(32))
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24  # 24 hours

security = HTTPBearer(auto_error=False)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash."""
    return bcrypt.checkpw(plain_password.encode('utf-8'), hashed_password.encode('utf-8'))


def get_password_hash(password: str) -> str:
    """Hash a password."""
    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Create a JWT access token."""
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)


def decode_access_token(token: str) -> Optional[dict]:
    """Decode and validate a JWT token."""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None


# ============================================================================
# RBAC ROLE CHECKING (defined after User model is available)
# ============================================================================

# Role hierarchy for RBAC
ROLE_HIERARCHY = {
    "super_admin": 100,
    "org_admin": 80,
    "site_manager": 60,
    "engineer": 40,
    "billing_admin": 30,
    "viewer": 10
}

def get_role_level(role: str) -> int:
    """Get the numeric level for a role."""
    return ROLE_HIERARCHY.get(role, 0)


from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Float, Enum, Text, Date, Time
from sqlalchemy.orm import relationship
from pydantic import BaseModel, Field, ConfigDict


class AssetType(PyEnum):
    """Types of assets in the electrical hierarchy (SLD)."""
    MAIN_BREAKER = "main_breaker"
    SUB_PANEL = "sub_panel"
    DISTRIBUTION_BOARD = "distribution_board"
    CONSUMER = "consumer"
    TRANSFORMER = "transformer"
    GENERATOR = "generator"
    SOLAR_INVERTER = "solar_inverter"
    BATTERY_STORAGE = "battery_storage"


class NotificationType(PyEnum):
    """Types of notifications generated by AI agents."""
    MISSING_METER = "missing_meter"
    PEAK_SHAVING_ALERT = "peak_shaving_alert"
    BILL_VARIANCE = "bill_variance"
    ANOMALY_DETECTED = "anomaly_detected"
    SOLAR_ROI_UPDATE = "solar_roi_update"
    MAINTENANCE_REQUIRED = "maintenance_required"
    OPTIMIZATION_SUGGESTION = "optimization_suggestion"


class Site(Base):
    """Site model representing a physical facility or location."""
    __tablename__ = "sites"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False, index=True)
    address = Column(Text, nullable=True)
    city = Column(String(100), nullable=True)
    country = Column(String(100), nullable=True)
    latitude = Column(Float, nullable=True)
    longitude = Column(Float, nullable=True)
    timezone = Column(String(50), default="UTC")
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    assets = relationship("Asset", back_populates="site", cascade="all, delete-orphan")
    meters = relationship("Meter", back_populates="site", cascade="all, delete-orphan")
    bills = relationship("Bill", back_populates="site", cascade="all, delete-orphan")
    tariffs = relationship("Tariff", back_populates="site", cascade="all, delete-orphan")
    notifications = relationship("Notification", back_populates="site", cascade="all, delete-orphan")


class Asset(Base):
    """Asset model representing electrical components in the SLD hierarchy."""
    __tablename__ = "assets"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    parent_id = Column(Integer, ForeignKey("assets.id"), nullable=True, index=True)
    name = Column(String(255), nullable=False)
    asset_type = Column(Enum(AssetType), nullable=False)
    description = Column(Text, nullable=True)
    rated_capacity_kw = Column(Float, nullable=True)
    rated_voltage = Column(Float, nullable=True)
    rated_current = Column(Float, nullable=True)
    is_critical = Column(Integer, default=0)
    requires_metering = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    site = relationship("Site", back_populates="assets")
    parent = relationship("Asset", remote_side=[id], back_populates="children")
    children = relationship("Asset", back_populates="parent", cascade="all, delete-orphan")
    meter = relationship("Meter", back_populates="asset", uselist=False)


class Meter(Base):
    """Meter model representing a physical energy meter device."""
    __tablename__ = "meters"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    asset_id = Column(Integer, ForeignKey("assets.id"), nullable=True, index=True)
    meter_id = Column(String(100), unique=True, nullable=False, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    manufacturer = Column(String(100), nullable=True)
    model = Column(String(100), nullable=True)
    serial_number = Column(String(100), nullable=True)
    is_active = Column(Integer, default=1)
    is_bidirectional = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    site = relationship("Site", back_populates="meters")
    asset = relationship("Asset", back_populates="meter")
    readings = relationship("MeterReading", back_populates="meter", cascade="all, delete-orphan")


class MeterReading(Base):
    """MeterReading model for time-series energy data."""
    __tablename__ = "meter_readings"

    id = Column(Integer, primary_key=True, index=True)
    meter_id = Column(Integer, ForeignKey("meters.id"), nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    energy_kwh = Column(Float, nullable=False)
    power_kw = Column(Float, nullable=True)
    voltage = Column(Float, nullable=True)
    current = Column(Float, nullable=True)
    power_factor = Column(Float, nullable=True)
    reactive_power_kvar = Column(Float, nullable=True)
    apparent_power_kva = Column(Float, nullable=True)
    reading_type = Column(String(50), default="interval")
    created_at = Column(DateTime, default=datetime.utcnow)

    meter = relationship("Meter", back_populates="readings")


class Bill(Base):
    """Bill model representing a utility bill for a site."""
    __tablename__ = "bills"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    tariff_id = Column(Integer, ForeignKey("tariffs.id"), nullable=True, index=True)
    bill_number = Column(String(100), nullable=True, index=True)
    provider_name = Column(String(255), nullable=True)
    period_start = Column(Date, nullable=False)
    period_end = Column(Date, nullable=False)
    issue_date = Column(Date, nullable=True)
    due_date = Column(Date, nullable=True)
    total_kwh = Column(Float, nullable=False)
    total_amount = Column(Float, nullable=False)
    currency = Column(String(10), default="USD")
    peak_kwh = Column(Float, nullable=True)
    off_peak_kwh = Column(Float, nullable=True)
    demand_kw = Column(Float, nullable=True)
    power_factor_penalty = Column(Float, nullable=True)
    taxes = Column(Float, nullable=True)
    other_charges = Column(Float, nullable=True)
    notes = Column(Text, nullable=True)
    is_validated = Column(Integer, default=0)
    validation_variance_pct = Column(Float, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    site = relationship("Site", back_populates="bills")
    tariff = relationship("Tariff", back_populates="bills")
    line_items = relationship("BillLineItem", back_populates="bill", cascade="all, delete-orphan")


class BillLineItem(Base):
    """BillLineItem model for detailed bill breakdown."""
    __tablename__ = "bill_line_items"

    id = Column(Integer, primary_key=True, index=True)
    bill_id = Column(Integer, ForeignKey("bills.id"), nullable=False, index=True)
    description = Column(String(255), nullable=False)
    category = Column(String(100), nullable=True)
    quantity = Column(Float, nullable=True)
    unit = Column(String(50), nullable=True)
    unit_price = Column(Float, nullable=True)
    amount = Column(Float, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    bill = relationship("Bill", back_populates="line_items")


class Tariff(Base):
    """Tariff model representing a utility pricing structure."""
    __tablename__ = "tariffs"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    provider_name = Column(String(255), nullable=True)
    effective_from = Column(DateTime, nullable=True)
    effective_to = Column(DateTime, nullable=True)
    currency = Column(String(10), default="USD")
    fixed_charge = Column(Float, default=0.0)
    demand_charge_per_kw = Column(Float, nullable=True)
    power_factor_threshold = Column(Float, nullable=True)
    power_factor_penalty_rate = Column(Float, nullable=True)
    is_active = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    site = relationship("Site", back_populates="tariffs")
    rates = relationship("TariffRate", back_populates="tariff", cascade="all, delete-orphan")
    bills = relationship("Bill", back_populates="tariff")


class TariffRate(Base):
    """TariffRate model for time-of-use pricing periods."""
    __tablename__ = "tariff_rates"

    id = Column(Integer, primary_key=True, index=True)
    tariff_id = Column(Integer, ForeignKey("tariffs.id"), nullable=False, index=True)
    name = Column(String(100), nullable=False)
    rate_per_kwh = Column(Float, nullable=False)
    time_start = Column(Time, nullable=True)
    time_end = Column(Time, nullable=True)
    days_of_week = Column(String(50), nullable=True)
    season = Column(String(50), nullable=True)
    tier_min_kwh = Column(Float, nullable=True)
    tier_max_kwh = Column(Float, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    tariff = relationship("Tariff", back_populates="rates")


class Notification(Base):
    """Notification model for AI-generated alerts."""
    __tablename__ = "notifications"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    asset_id = Column(Integer, ForeignKey("assets.id"), nullable=True, index=True)
    notification_type = Column(Enum(NotificationType), nullable=False)
    severity = Column(String(20), default="info")
    title = Column(String(255), nullable=False)
    message = Column(Text, nullable=False)
    is_read = Column(Integer, default=0)
    is_resolved = Column(Integer, default=0)
    agent_name = Column(String(100), nullable=True)
    extra_data = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    resolved_at = Column(DateTime, nullable=True)

    site = relationship("Site", back_populates="notifications")


# ============================================================================
# ENTERPRISE EDITION MODELS
# ============================================================================

class DataSourceType(PyEnum):
    """Types of data sources for integration layer."""
    MODBUS_TCP = "modbus_tcp"
    MODBUS_RTU = "modbus_rtu"
    BACNET = "bacnet"
    CSV_IMPORT = "csv_import"
    EXTERNAL_API = "external_api"
    MANUAL = "manual"


class InvoiceStatus(PyEnum):
    """Status of tenant invoices."""
    DRAFT = "draft"
    PENDING = "pending"
    SENT = "sent"
    PAID = "paid"
    OVERDUE = "overdue"
    CANCELLED = "cancelled"


class DataSource(Base):
    """DataSource model for integration layer - connects to external systems."""
    __tablename__ = "data_sources"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    name = Column(String(255), nullable=False)
    source_type = Column(Enum(DataSourceType), nullable=False)
    connection_string = Column(Text, nullable=True)
    host = Column(String(255), nullable=True)
    port = Column(Integer, nullable=True)
    slave_id = Column(Integer, nullable=True)
    polling_interval_seconds = Column(Integer, default=60)
    is_active = Column(Integer, default=1)
    last_poll_at = Column(DateTime, nullable=True)
    last_error = Column(Text, nullable=True)
    config_json = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    measurements = relationship("Measurement", back_populates="data_source", cascade="all, delete-orphan")


class Measurement(Base):
    """Measurement model for normalized meter readings from all data sources.
    
    This table should be converted to a TimescaleDB hypertable for high-frequency data.
    """
    __tablename__ = "measurements"

    id = Column(Integer, primary_key=True, index=True)
    data_source_id = Column(Integer, ForeignKey("data_sources.id"), nullable=False, index=True)
    meter_id = Column(Integer, ForeignKey("meters.id"), nullable=True, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    value = Column(Float, nullable=False)
    unit = Column(String(50), nullable=False)
    quality = Column(String(20), default="good")
    raw_value = Column(Float, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    data_source = relationship("DataSource", back_populates="measurements")


class Tenant(Base):
    """Tenant model for sub-billing in multi-tenant facilities."""
    __tablename__ = "tenants"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    name = Column(String(255), nullable=False)
    contact_name = Column(String(255), nullable=True)
    contact_email = Column(String(255), nullable=True)
    contact_phone = Column(String(50), nullable=True)
    billing_address = Column(Text, nullable=True)
    tax_id = Column(String(100), nullable=True)
    is_active = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    lease_contracts = relationship("LeaseContract", back_populates="tenant", cascade="all, delete-orphan")
    invoices = relationship("Invoice", back_populates="tenant", cascade="all, delete-orphan")


class LeaseContract(Base):
    """LeaseContract model defining billing rules for a tenant."""
    __tablename__ = "lease_contracts"

    id = Column(Integer, primary_key=True, index=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False, index=True)
    meter_id = Column(Integer, ForeignKey("meters.id"), nullable=True, index=True)
    name = Column(String(255), nullable=False)
    start_date = Column(Date, nullable=False)
    end_date = Column(Date, nullable=True)
    rate_per_kwh = Column(Float, nullable=False)
    fixed_monthly_fee = Column(Float, default=0.0)
    loss_factor_percent = Column(Float, default=0.0)
    demand_charge_per_kw = Column(Float, default=0.0)
    min_monthly_charge = Column(Float, default=0.0)
    billing_day = Column(Integer, default=1)
    is_active = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    tenant = relationship("Tenant", back_populates="lease_contracts")


class Invoice(Base):
    """Invoice model for tenant billing."""
    __tablename__ = "invoices"

    id = Column(Integer, primary_key=True, index=True)
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False, index=True)
    lease_contract_id = Column(Integer, ForeignKey("lease_contracts.id"), nullable=True, index=True)
    invoice_number = Column(String(100), unique=True, nullable=False, index=True)
    billing_period_start = Column(Date, nullable=False)
    billing_period_end = Column(Date, nullable=False)
    consumption_kwh = Column(Float, default=0.0)
    peak_demand_kw = Column(Float, nullable=True)
    energy_charge = Column(Float, default=0.0)
    demand_charge = Column(Float, default=0.0)
    fixed_fee = Column(Float, default=0.0)
    loss_charge = Column(Float, default=0.0)
    subtotal = Column(Float, default=0.0)
    tax_amount = Column(Float, default=0.0)
    total_amount = Column(Float, default=0.0)
    status = Column(Enum(InvoiceStatus), default=InvoiceStatus.DRAFT)
    due_date = Column(Date, nullable=True)
    paid_date = Column(Date, nullable=True)
    notes = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    tenant = relationship("Tenant", back_populates="invoices")


class BatterySpecs(Base):
    """BatterySpecs model for BESS financial analysis."""
    __tablename__ = "battery_specs"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    name = Column(String(255), nullable=False)
    capacity_kwh = Column(Float, nullable=False)
    power_rating_kw = Column(Float, nullable=False)
    round_trip_efficiency = Column(Float, default=0.90)
    depth_of_discharge = Column(Float, default=0.90)
    cycle_life = Column(Integer, default=6000)
    capex_total = Column(Float, nullable=False)
    opex_annual = Column(Float, default=0.0)
    warranty_years = Column(Integer, default=10)
    degradation_rate_annual = Column(Float, default=0.02)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


# ============================================================================
# PLATFORM FOUNDATION MODELS (Phase 1)
# ============================================================================

class UserRole(PyEnum):
    """User roles for RBAC."""
    SUPER_ADMIN = "super_admin"
    ORG_ADMIN = "org_admin"
    SITE_MANAGER = "site_manager"
    ANALYST = "analyst"
    OPERATOR = "operator"
    VIEWER = "viewer"


class AuditAction(PyEnum):
    """Actions tracked in audit logs."""
    CREATE = "create"
    UPDATE = "update"
    DELETE = "delete"
    LOGIN = "login"
    LOGOUT = "logout"
    APPROVE = "approve"
    REJECT = "reject"
    LOCK = "lock"
    UNLOCK = "unlock"
    EXPORT = "export"
    IMPORT = "import"


class FileStatus(PyEnum):
    """Status of uploaded files."""
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    ARCHIVED = "archived"


class PeriodStatus(PyEnum):
    """Status of billing/reporting periods."""
    OPEN = "open"
    LOCKED = "locked"
    CLOSED = "closed"


class NotificationChannel(PyEnum):
    """Channels for notifications."""
    INBOX = "inbox"
    EMAIL = "email"
    WEBHOOK = "webhook"
    PUSH = "push"


class Organization(Base):
    """Organization model for multi-tenant hierarchy (Org → Sites → Users)."""
    __tablename__ = "organizations"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False, index=True)
    slug = Column(String(100), unique=True, nullable=False, index=True)
    logo_url = Column(String(500), nullable=True)
    primary_color = Column(String(20), default="#1a56db")
    secondary_color = Column(String(20), default="#7e22ce")
    billing_email = Column(String(255), nullable=True)
    billing_address = Column(Text, nullable=True)
    tax_id = Column(String(100), nullable=True)
    subscription_plan = Column(String(50), default="starter")
    is_active = Column(Integer, default=1)
    mfa_required = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    users = relationship("User", back_populates="organization", cascade="all, delete-orphan")
    org_sites = relationship("OrgSite", back_populates="organization", cascade="all, delete-orphan")


class User(Base):
    """User model with RBAC support."""
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    organization_id = Column(Integer, ForeignKey("organizations.id"), nullable=False, index=True)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    first_name = Column(String(100), nullable=True)
    last_name = Column(String(100), nullable=True)
    phone = Column(String(50), nullable=True)
    role = Column(Enum(UserRole), default=UserRole.VIEWER)
    is_active = Column(Integer, default=1)
    mfa_enabled = Column(Integer, default=0)
    mfa_secret = Column(String(255), nullable=True)
    last_login_at = Column(DateTime, nullable=True)
    failed_login_attempts = Column(Integer, default=0)
    locked_until = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    organization = relationship("Organization", back_populates="users")
    site_permissions = relationship("UserSitePermission", back_populates="user", cascade="all, delete-orphan")
    audit_logs = relationship("AuditLog", back_populates="user")
    notification_preferences = relationship("NotificationPreference", back_populates="user", cascade="all, delete-orphan")


class OrgSite(Base):
    """Links Organizations to Sites (many-to-many with metadata)."""
    __tablename__ = "org_sites"

    id = Column(Integer, primary_key=True, index=True)
    organization_id = Column(Integer, ForeignKey("organizations.id"), nullable=False, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    is_primary = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)

    organization = relationship("Organization", back_populates="org_sites")


class UserSitePermission(Base):
    """User permissions for specific sites."""
    __tablename__ = "user_site_permissions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    can_view = Column(Integer, default=1)
    can_edit = Column(Integer, default=0)
    can_delete = Column(Integer, default=0)
    can_manage_users = Column(Integer, default=0)
    can_approve = Column(Integer, default=0)
    can_export = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)

    user = relationship("User", back_populates="site_permissions")


class AuditLog(Base):
    """Immutable audit log for tracking all significant changes."""
    __tablename__ = "audit_logs"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True, index=True)
    organization_id = Column(Integer, ForeignKey("organizations.id"), nullable=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=True, index=True)
    action = Column(Enum(AuditAction), nullable=False, index=True)
    entity_type = Column(String(100), nullable=False, index=True)
    entity_id = Column(Integer, nullable=True, index=True)
    before_state = Column(Text, nullable=True)
    after_state = Column(Text, nullable=True)
    ip_address = Column(String(50), nullable=True)
    user_agent = Column(String(500), nullable=True)
    correlation_id = Column(String(100), nullable=True, index=True)
    metadata_json = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, index=True)

    user = relationship("User", back_populates="audit_logs")


class FileAsset(Base):
    """File management with versioning and status tracking."""
    __tablename__ = "file_assets"

    id = Column(Integer, primary_key=True, index=True)
    organization_id = Column(Integer, ForeignKey("organizations.id"), nullable=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=True, index=True)
    uploaded_by_id = Column(Integer, ForeignKey("users.id"), nullable=True, index=True)
    file_name = Column(String(255), nullable=False)
    original_name = Column(String(255), nullable=False)
    file_type = Column(String(100), nullable=True)
    mime_type = Column(String(100), nullable=True)
    file_size_bytes = Column(Integer, nullable=True)
    storage_path = Column(String(500), nullable=False)
    storage_provider = Column(String(50), default="local")
    version = Column(Integer, default=1)
    parent_file_id = Column(Integer, ForeignKey("file_assets.id"), nullable=True)
    status = Column(Enum(FileStatus), default=FileStatus.PENDING)
    processing_result = Column(Text, nullable=True)
    checksum = Column(String(100), nullable=True)
    metadata_json = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class PeriodLock(Base):
    """Period lock for billing/reporting periods - prevents edits to historical data."""
    __tablename__ = "period_locks"

    id = Column(Integer, primary_key=True, index=True)
    organization_id = Column(Integer, ForeignKey("organizations.id"), nullable=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=True, index=True)
    period_type = Column(String(50), nullable=False)
    period_start = Column(Date, nullable=False)
    period_end = Column(Date, nullable=False)
    status = Column(Enum(PeriodStatus), default=PeriodStatus.OPEN)
    locked_by_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    locked_at = Column(DateTime, nullable=True)
    unlock_reason = Column(Text, nullable=True)
    snapshot_data = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class NotificationTemplate(Base):
    """Templates for notification messages."""
    __tablename__ = "notification_templates"

    id = Column(Integer, primary_key=True, index=True)
    organization_id = Column(Integer, ForeignKey("organizations.id"), nullable=True, index=True)
    name = Column(String(100), nullable=False)
    notification_type = Column(Enum(NotificationType), nullable=False)
    channel = Column(Enum(NotificationChannel), nullable=False)
    subject_template = Column(String(255), nullable=True)
    body_template = Column(Text, nullable=False)
    is_active = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class NotificationPreference(Base):
    """User preferences for notification channels."""
    __tablename__ = "notification_preferences"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    notification_type = Column(Enum(NotificationType), nullable=False)
    channel = Column(Enum(NotificationChannel), nullable=False)
    is_enabled = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)

    user = relationship("User", back_populates="notification_preferences")


class NotificationDelivery(Base):
    """Tracks delivery status of notifications."""
    __tablename__ = "notification_deliveries"

    id = Column(Integer, primary_key=True, index=True)
    notification_id = Column(Integer, ForeignKey("notifications.id"), nullable=False, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    channel = Column(Enum(NotificationChannel), nullable=False)
    status = Column(String(50), default="pending")
    sent_at = Column(DateTime, nullable=True)
    delivered_at = Column(DateTime, nullable=True)
    read_at = Column(DateTime, nullable=True)
    error_message = Column(Text, nullable=True)
    retry_count = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)


# ============================================================================
# DATA QUALITY ENGINE MODELS (Phase 2)
# ============================================================================

class QualityIssueType(PyEnum):
    """Types of data quality issues."""
    MISSING_DATA = "missing_data"
    DUPLICATE = "duplicate"
    METER_RESET = "meter_reset"
    SPIKE = "spike"
    OUTLIER = "outlier"
    NEGATIVE_VALUE = "negative_value"
    STALE_DATA = "stale_data"
    CONNECTIVITY_GAP = "connectivity_gap"


class DataQualityRule(Base):
    """Rules for data quality validation."""
    __tablename__ = "data_quality_rules"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    issue_type = Column(Enum(QualityIssueType), nullable=False)
    rule_expression = Column(Text, nullable=False)
    severity = Column(String(20), default="warning")
    is_active = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)


class QualityIssue(Base):
    """Detected data quality issues."""
    __tablename__ = "quality_issues"

    id = Column(Integer, primary_key=True, index=True)
    meter_id = Column(Integer, ForeignKey("meters.id"), nullable=False, index=True)
    rule_id = Column(Integer, ForeignKey("data_quality_rules.id"), nullable=True, index=True)
    issue_type = Column(Enum(QualityIssueType), nullable=False, index=True)
    severity = Column(String(20), default="warning")
    timestamp_start = Column(DateTime, nullable=False, index=True)
    timestamp_end = Column(DateTime, nullable=True)
    description = Column(Text, nullable=True)
    expected_value = Column(Float, nullable=True)
    actual_value = Column(Float, nullable=True)
    is_resolved = Column(Integer, default=0)
    resolved_by_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    resolved_at = Column(DateTime, nullable=True)
    resolution_notes = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)


class MeterQualitySummary(Base):
    """Daily quality summary per meter."""
    __tablename__ = "meter_quality_summaries"

    id = Column(Integer, primary_key=True, index=True)
    meter_id = Column(Integer, ForeignKey("meters.id"), nullable=False, index=True)
    date = Column(Date, nullable=False, index=True)
    expected_readings = Column(Integer, default=0)
    actual_readings = Column(Integer, default=0)
    coverage_percent = Column(Float, default=0.0)
    quality_score = Column(Float, default=100.0)
    issues_count = Column(Integer, default=0)
    gaps_minutes = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)


# ============================================================================
# VIRTUAL METERS & EXPRESSION ENGINE (Phase 3)
# ============================================================================

class VirtualMeterType(PyEnum):
    """Types of virtual meters."""
    CALCULATED = "calculated"
    AGGREGATED = "aggregated"
    ALLOCATED = "allocated"
    DIFFERENTIAL = "differential"


class VirtualMeter(Base):
    """Virtual meters for calculated/allocated values."""
    __tablename__ = "virtual_meters"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    meter_type = Column(Enum(VirtualMeterType), nullable=False)
    expression = Column(Text, nullable=True)
    unit = Column(String(50), default="kWh")
    is_active = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    components = relationship("VirtualMeterComponent", back_populates="virtual_meter", cascade="all, delete-orphan")


class VirtualMeterComponent(Base):
    """Components (source meters) of a virtual meter."""
    __tablename__ = "virtual_meter_components"

    id = Column(Integer, primary_key=True, index=True)
    virtual_meter_id = Column(Integer, ForeignKey("virtual_meters.id"), nullable=False, index=True)
    meter_id = Column(Integer, ForeignKey("meters.id"), nullable=True, index=True)
    weight = Column(Float, default=1.0)
    operator = Column(String(10), default="+")
    allocation_percent = Column(Float, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    virtual_meter = relationship("VirtualMeter", back_populates="components")


class AllocationRule(Base):
    """Allocation rules for tenant billing."""
    __tablename__ = "allocation_rules"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    rule_type = Column(String(50), nullable=False)
    source_meter_id = Column(Integer, ForeignKey("meters.id"), nullable=True)
    allocation_method = Column(String(50), default="proportional")
    allocation_config = Column(Text, nullable=True)
    is_active = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)


# ============================================================================
# PREDICTIVE MAINTENANCE (Phase 4)
# ============================================================================

class MaintenanceRuleType(PyEnum):
    """Types of predictive maintenance rules."""
    OVERLOAD = "overload"
    PF_DEGRADATION = "pf_degradation"
    TEMPERATURE = "temperature"
    POWER_QUALITY = "power_quality"
    USAGE_PATTERN = "usage_pattern"
    LIFECYCLE = "lifecycle"


class MaintenanceCondition(PyEnum):
    """Asset condition states."""
    EXCELLENT = "excellent"
    GOOD = "good"
    FAIR = "fair"
    POOR = "poor"
    CRITICAL = "critical"


class MaintenanceRule(Base):
    """Rules for predictive maintenance alerts."""
    __tablename__ = "maintenance_rules"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    rule_type = Column(Enum(MaintenanceRuleType), nullable=False)
    condition_expression = Column(Text, nullable=False)
    threshold_value = Column(Float, nullable=True)
    severity = Column(String(20), default="warning")
    is_active = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)


class AssetCondition(Base):
    """Tracks asset health/condition over time."""
    __tablename__ = "asset_conditions"

    id = Column(Integer, primary_key=True, index=True)
    asset_id = Column(Integer, ForeignKey("assets.id"), nullable=False, index=True)
    condition = Column(Enum(MaintenanceCondition), default=MaintenanceCondition.GOOD)
    health_score = Column(Float, default=100.0)
    last_inspection_date = Column(Date, nullable=True)
    next_maintenance_date = Column(Date, nullable=True)
    estimated_remaining_life_years = Column(Float, nullable=True)
    notes = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class MaintenanceAlert(Base):
    """Predictive maintenance alerts."""
    __tablename__ = "maintenance_alerts"

    id = Column(Integer, primary_key=True, index=True)
    asset_id = Column(Integer, ForeignKey("assets.id"), nullable=False, index=True)
    rule_id = Column(Integer, ForeignKey("maintenance_rules.id"), nullable=True, index=True)
    alert_type = Column(Enum(MaintenanceRuleType), nullable=False)
    severity = Column(String(20), default="warning")
    title = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    triggered_value = Column(Float, nullable=True)
    threshold_value = Column(Float, nullable=True)
    status = Column(String(50), default="open")
    acknowledged_by_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    acknowledged_at = Column(DateTime, nullable=True)
    resolved_at = Column(DateTime, nullable=True)
    resolution_notes = Column(Text, nullable=True)
    evidence_json = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)


# ============================================================================
# AI AGENTS & FORECASTING (Phase 4)
# ============================================================================

class AgentType(PyEnum):
    """Types of AI agents."""
    ENERGY_ANALYST = "energy_analyst"
    DETECTIVE = "detective"
    RECOMMENDER = "recommender"
    FORECASTER = "forecaster"


class AgentSession(Base):
    """AI agent conversation sessions."""
    __tablename__ = "agent_sessions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=True, index=True)
    agent_type = Column(Enum(AgentType), nullable=False)
    context_json = Column(Text, nullable=True)
    status = Column(String(50), default="active")
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class AgentMessage(Base):
    """Messages in AI agent conversations."""
    __tablename__ = "agent_messages"

    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(Integer, ForeignKey("agent_sessions.id"), nullable=False, index=True)
    role = Column(String(20), nullable=False)
    content = Column(Text, nullable=False)
    evidence_json = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)


class Recommendation(Base):
    """AI-generated recommendations pending approval."""
    __tablename__ = "recommendations"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    agent_type = Column(Enum(AgentType), nullable=False)
    category = Column(String(100), nullable=False)
    title = Column(String(255), nullable=False)
    description = Column(Text, nullable=False)
    expected_savings = Column(Float, nullable=True)
    confidence_score = Column(Float, nullable=True)
    priority = Column(String(20), default="medium")
    status = Column(String(50), default="pending")
    approved_by_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    approved_at = Column(DateTime, nullable=True)
    rejected_reason = Column(Text, nullable=True)
    evidence_json = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)


class ForecastJob(Base):
    """Forecasting jobs for load/PV predictions."""
    __tablename__ = "forecast_jobs"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    meter_id = Column(Integer, ForeignKey("meters.id"), nullable=True, index=True)
    forecast_type = Column(String(50), nullable=False)
    horizon_hours = Column(Integer, default=24)
    model_name = Column(String(100), nullable=True)
    status = Column(String(50), default="pending")
    started_at = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)
    error_message = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)


class ForecastSeries(Base):
    """Forecast data points."""
    __tablename__ = "forecast_series"

    id = Column(Integer, primary_key=True, index=True)
    job_id = Column(Integer, ForeignKey("forecast_jobs.id"), nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    predicted_value = Column(Float, nullable=False)
    lower_bound = Column(Float, nullable=True)
    upper_bound = Column(Float, nullable=True)
    confidence = Column(Float, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)


# ============================================================================
# ACTIVE CONTROL (Phase 4 - Safety-first)
# ============================================================================

class ControlRuleType(PyEnum):
    """Types of automation control rules."""
    SCHEDULE = "schedule"
    THRESHOLD = "threshold"
    EVENT = "event"
    DEMAND_RESPONSE = "demand_response"


class SafetyGateStatus(PyEnum):
    """Status of safety gate checks."""
    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    EXPIRED = "expired"


class ControlRule(Base):
    """Automation rules for active control."""
    __tablename__ = "control_rules"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    rule_type = Column(Enum(ControlRuleType), nullable=False)
    trigger_condition = Column(Text, nullable=False)
    action_type = Column(String(100), nullable=False)
    action_params = Column(Text, nullable=True)
    target_asset_id = Column(Integer, ForeignKey("assets.id"), nullable=True)
    requires_approval = Column(Integer, default=1)
    requires_mfa = Column(Integer, default=0)
    is_active = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class SafetyGate(Base):
    """Safety gate for control action approval."""
    __tablename__ = "safety_gates"

    id = Column(Integer, primary_key=True, index=True)
    control_rule_id = Column(Integer, ForeignKey("control_rules.id"), nullable=False, index=True)
    name = Column(String(255), nullable=False)
    gate_type = Column(String(50), nullable=False)
    precondition = Column(Text, nullable=True)
    timeout_seconds = Column(Integer, default=300)
    requires_2fa = Column(Integer, default=0)
    whitelist_commands = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)


class ControlCommand(Base):
    """Control commands sent to devices."""
    __tablename__ = "control_commands"

    id = Column(Integer, primary_key=True, index=True)
    rule_id = Column(Integer, ForeignKey("control_rules.id"), nullable=True, index=True)
    asset_id = Column(Integer, ForeignKey("assets.id"), nullable=False, index=True)
    requested_by_id = Column(Integer, ForeignKey("users.id"), nullable=True, index=True)
    approved_by_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    command_type = Column(String(100), nullable=False)
    command_params = Column(Text, nullable=True)
    status = Column(String(50), default="pending")
    safety_gate_status = Column(Enum(SafetyGateStatus), default=SafetyGateStatus.PENDING)
    executed_at = Column(DateTime, nullable=True)
    result = Column(Text, nullable=True)
    rollback_command = Column(Text, nullable=True)
    expires_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)


class SiteCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=255)
    address: Optional[str] = None
    city: Optional[str] = None
    country: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    timezone: str = "UTC"


class SiteUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    address: Optional[str] = None
    city: Optional[str] = None
    country: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    timezone: Optional[str] = None


class SiteResponse(BaseModel):
    id: int
    name: str
    address: Optional[str] = None
    city: Optional[str] = None
    country: Optional[str] = None
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    timezone: str
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class AssetCreate(BaseModel):
    site_id: int
    parent_id: Optional[int] = None
    name: str = Field(..., min_length=1, max_length=255)
    asset_type: AssetType
    description: Optional[str] = None
    rated_capacity_kw: Optional[float] = None
    rated_voltage: Optional[float] = None
    rated_current: Optional[float] = None
    is_critical: bool = False
    requires_metering: bool = True


class AssetUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    asset_type: Optional[AssetType] = None
    description: Optional[str] = None
    parent_id: Optional[int] = None
    rated_capacity_kw: Optional[float] = None
    rated_voltage: Optional[float] = None
    rated_current: Optional[float] = None
    is_critical: Optional[bool] = None
    requires_metering: Optional[bool] = None


class AssetResponse(BaseModel):
    id: int
    site_id: int
    parent_id: Optional[int] = None
    name: str
    asset_type: AssetType
    description: Optional[str] = None
    rated_capacity_kw: Optional[float] = None
    rated_voltage: Optional[float] = None
    rated_current: Optional[float] = None
    is_critical: bool = False
    requires_metering: bool = True
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class AssetTreeNode(BaseModel):
    id: int
    name: str
    asset_type: AssetType
    has_meter: bool = False
    meter_id: Optional[str] = None
    children: List["AssetTreeNode"] = []

    model_config = ConfigDict(from_attributes=True)


AssetTreeNode.model_rebuild()


class MeterCreate(BaseModel):
    site_id: int
    asset_id: Optional[int] = None
    meter_id: str = Field(..., min_length=1, max_length=100)
    name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    manufacturer: Optional[str] = None
    model: Optional[str] = None
    serial_number: Optional[str] = None
    is_active: bool = True
    is_bidirectional: bool = False


class MeterUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    description: Optional[str] = None
    asset_id: Optional[int] = None
    manufacturer: Optional[str] = None
    model: Optional[str] = None
    serial_number: Optional[str] = None
    is_active: Optional[bool] = None
    is_bidirectional: Optional[bool] = None


class MeterResponse(BaseModel):
    id: int
    site_id: int
    asset_id: Optional[int] = None
    meter_id: str
    name: str
    description: Optional[str] = None
    manufacturer: Optional[str] = None
    model: Optional[str] = None
    serial_number: Optional[str] = None
    is_active: bool
    is_bidirectional: bool
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class MeterReadingCreate(BaseModel):
    meter_id: int
    timestamp: datetime
    energy_kwh: float
    power_kw: Optional[float] = None
    voltage: Optional[float] = None
    current: Optional[float] = None
    power_factor: Optional[float] = None
    reactive_power_kvar: Optional[float] = None
    apparent_power_kva: Optional[float] = None
    reading_type: str = "interval"


class MeterReadingResponse(BaseModel):
    id: int
    meter_id: int
    timestamp: datetime
    energy_kwh: float
    power_kw: Optional[float] = None
    voltage: Optional[float] = None
    current: Optional[float] = None
    power_factor: Optional[float] = None
    reactive_power_kvar: Optional[float] = None
    apparent_power_kva: Optional[float] = None
    reading_type: str
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class BillLineItemCreate(BaseModel):
    description: str
    category: Optional[str] = None
    quantity: Optional[float] = None
    unit: Optional[str] = None
    unit_price: Optional[float] = None
    amount: float


class BillLineItemResponse(BaseModel):
    id: int
    bill_id: int
    description: str
    category: Optional[str] = None
    quantity: Optional[float] = None
    unit: Optional[str] = None
    unit_price: Optional[float] = None
    amount: float
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class BillCreate(BaseModel):
    site_id: int
    tariff_id: Optional[int] = None
    bill_number: Optional[str] = None
    provider_name: Optional[str] = None
    period_start: date
    period_end: date
    issue_date: Optional[date] = None
    due_date: Optional[date] = None
    total_kwh: float
    total_amount: float
    currency: str = "USD"
    peak_kwh: Optional[float] = None
    off_peak_kwh: Optional[float] = None
    demand_kw: Optional[float] = None
    power_factor_penalty: Optional[float] = None
    taxes: Optional[float] = None
    other_charges: Optional[float] = None
    notes: Optional[str] = None
    line_items: List[BillLineItemCreate] = []


class BillUpdate(BaseModel):
    bill_number: Optional[str] = None
    provider_name: Optional[str] = None
    period_start: Optional[date] = None
    period_end: Optional[date] = None
    issue_date: Optional[date] = None
    due_date: Optional[date] = None
    total_kwh: Optional[float] = None
    total_amount: Optional[float] = None
    currency: Optional[str] = None
    tariff_id: Optional[int] = None
    notes: Optional[str] = None


class BillResponse(BaseModel):
    id: int
    site_id: int
    tariff_id: Optional[int] = None
    bill_number: Optional[str] = None
    provider_name: Optional[str] = None
    period_start: date
    period_end: date
    issue_date: Optional[date] = None
    due_date: Optional[date] = None
    total_kwh: float
    total_amount: float
    currency: str
    peak_kwh: Optional[float] = None
    off_peak_kwh: Optional[float] = None
    demand_kw: Optional[float] = None
    power_factor_penalty: Optional[float] = None
    taxes: Optional[float] = None
    other_charges: Optional[float] = None
    notes: Optional[str] = None
    is_validated: bool
    validation_variance_pct: Optional[float] = None
    created_at: datetime
    updated_at: datetime
    line_items: List[BillLineItemResponse] = []

    model_config = ConfigDict(from_attributes=True)


class BillValidationResult(BaseModel):
    bill_id: int
    is_valid: bool
    bill_total_kwh: float
    meter_total_kwh: float
    variance_kwh: float
    variance_percentage: float
    message: str


class UnmeteredAsset(BaseModel):
    asset_id: int
    asset_name: str
    asset_type: AssetType
    parent_id: Optional[int] = None
    parent_name: Optional[str] = None
    rated_capacity_kw: Optional[float] = None
    is_critical: bool = False
    hierarchy_path: List[str] = []


class GapAnalysisResult(BaseModel):
    site_id: int
    site_name: str
    total_assets: int
    metered_assets: int
    unmetered_assets: int
    coverage_percentage: float
    critical_unmetered_count: int
    unmetered_asset_list: List[UnmeteredAsset] = []
    recommendations: List[str] = []


class NotificationResponse(BaseModel):
    id: int
    site_id: int
    asset_id: Optional[int] = None
    notification_type: NotificationType
    severity: str
    title: str
    message: str
    is_read: bool
    is_resolved: bool
    agent_name: Optional[str] = None
    extra_data: Optional[str] = None
    created_at: datetime
    resolved_at: Optional[datetime] = None

    model_config = ConfigDict(from_attributes=True)


class TariffCreate(BaseModel):
    """Create a new tariff schedule."""
    site_id: int
    name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    provider_name: Optional[str] = None
    effective_from: Optional[datetime] = None
    effective_to: Optional[datetime] = None
    currency: str = "USD"
    fixed_charge: float = 0.0
    demand_charge_per_kw: Optional[float] = None
    power_factor_threshold: Optional[float] = None
    power_factor_penalty_rate: Optional[float] = None
    tariff_type: str = "flat"
    rate_per_kwh: float = 0.12
    peak_rate: Optional[float] = None
    off_peak_rate: Optional[float] = None
    is_active: bool = True


class TariffResponse(BaseModel):
    """Response for tariff queries."""
    id: int
    site_id: int
    name: str
    description: Optional[str] = None
    provider_name: Optional[str] = None
    effective_from: Optional[datetime] = None
    effective_to: Optional[datetime] = None
    currency: str
    fixed_charge: float
    demand_charge_per_kw: Optional[float] = None
    demand_rate_per_kw: Optional[float] = None
    power_factor_threshold: Optional[float] = None
    power_factor_penalty_rate: Optional[float] = None
    tariff_type: str = "flat"
    rate_per_kwh: float = 0.12
    peak_rate: Optional[float] = None
    off_peak_rate: Optional[float] = None
    is_active: bool
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class SolarROIInput(BaseModel):
    """Input parameters for Solar ROI calculation."""
    annual_consumption_kwh: float
    average_electricity_rate: float
    system_size_kw: float
    installation_cost: float
    annual_solar_production_kwh_per_kw: float = 1400
    annual_degradation_rate: float = 0.005
    maintenance_cost_annual: float = 0.0
    incentive_amount: float = 0.0
    net_metering_rate: Optional[float] = None
    analysis_period_years: int = 25
    inflation_rate: float = 0.03


class SolarROIResult(BaseModel):
    """Result of Solar ROI calculation."""
    system_size_kw: float
    installation_cost: float
    year_one_production_kwh: float
    year_one_savings: float
    simple_payback_years: float
    net_present_value: float
    internal_rate_of_return: float
    lifetime_savings: float
    break_even_year: Optional[int]
    annual_projections: List[dict]


# ============================================================================
# ENTERPRISE EDITION SCHEMAS
# ============================================================================

class TenantCreate(BaseModel):
    """Schema for creating a tenant."""
    site_id: int
    name: str = Field(..., min_length=1, max_length=255)
    contact_name: Optional[str] = None
    contact_email: Optional[str] = None
    contact_phone: Optional[str] = None
    billing_address: Optional[str] = None
    tax_id: Optional[str] = None


class TenantResponse(BaseModel):
    """Response schema for tenant."""
    id: int
    site_id: int
    name: str
    contact_name: Optional[str] = None
    contact_email: Optional[str] = None
    contact_phone: Optional[str] = None
    billing_address: Optional[str] = None
    tax_id: Optional[str] = None
    is_active: bool
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class LeaseContractCreate(BaseModel):
    """Schema for creating a lease contract."""
    tenant_id: int
    meter_id: Optional[int] = None
    name: str = Field(..., min_length=1, max_length=255)
    start_date: date
    end_date: Optional[date] = None
    rate_per_kwh: float
    fixed_monthly_fee: float = 0.0
    loss_factor_percent: float = 0.0
    demand_charge_per_kw: float = 0.0
    min_monthly_charge: float = 0.0
    billing_day: int = 1


class LeaseContractResponse(BaseModel):
    """Response schema for lease contract."""
    id: int
    tenant_id: int
    meter_id: Optional[int] = None
    name: str
    start_date: date
    end_date: Optional[date] = None
    rate_per_kwh: float
    fixed_monthly_fee: float
    loss_factor_percent: float
    demand_charge_per_kw: float
    is_active: bool
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class InvoiceResponse(BaseModel):
    """Response schema for invoice."""
    id: int
    tenant_id: int
    invoice_number: str
    billing_period_start: date
    billing_period_end: date
    consumption_kwh: float
    peak_demand_kw: Optional[float] = None
    energy_charge: float
    demand_charge: float
    fixed_fee: float
    loss_charge: float
    subtotal: float
    tax_amount: float
    total_amount: float
    status: InvoiceStatus
    due_date: Optional[date] = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class BESSSimulationInput(BaseModel):
    """Input parameters for BESS financial simulation."""
    load_profile_kwh: List[float] = Field(..., description="8760 hourly load values (kWh) for a year")
    tariff_rates: List[float] = Field(..., description="8760 hourly electricity rates ($/kWh)")
    demand_charges: Optional[List[float]] = Field(None, description="12 monthly demand charges ($/kW)")
    battery_capacity_kwh: float = Field(..., gt=0)
    battery_power_kw: float = Field(..., gt=0)
    round_trip_efficiency: float = Field(default=0.90, ge=0.5, le=1.0)
    depth_of_discharge: float = Field(default=0.90, ge=0.5, le=1.0)
    capex: float = Field(..., gt=0)
    opex_annual: float = Field(default=0.0, ge=0)
    analysis_years: int = Field(default=15, ge=1, le=30)
    discount_rate: float = Field(default=0.08, ge=0, le=0.3)
    degradation_rate: float = Field(default=0.02, ge=0, le=0.1)


class BESSSimulationResult(BaseModel):
    """Result of BESS financial simulation."""
    arbitrage_savings_year1: float
    peak_shaving_savings_year1: float
    total_savings_year1: float
    simple_payback_years: float
    net_present_value: float
    internal_rate_of_return: Optional[float]
    lifetime_savings: float
    annual_projections: List[Dict[str, Any]]
    monthly_peak_reduction: List[float]


class DataSourceCreate(BaseModel):
    """Schema for creating a data source."""
    site_id: int
    name: str = Field(..., min_length=1, max_length=255)
    source_type: DataSourceType
    host: Optional[str] = None
    port: Optional[int] = None
    slave_id: Optional[int] = None
    polling_interval_seconds: int = 60
    config_json: Optional[str] = None


class DataSourceResponse(BaseModel):
    """Response schema for data source."""
    id: int
    site_id: int
    name: str
    source_type: DataSourceType
    host: Optional[str] = None
    port: Optional[int] = None
    polling_interval_seconds: int
    is_active: bool
    last_poll_at: Optional[datetime] = None
    last_error: Optional[str] = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class MeasurementCreate(BaseModel):
    """Schema for normalized measurement data."""
    data_source_id: int
    meter_id: Optional[int] = None
    timestamp: datetime
    value: float
    unit: str
    quality: str = "good"
    raw_value: Optional[float] = None


# ============================================================================
# PLATFORM FOUNDATION SCHEMAS (Phase 1)
# ============================================================================

class OrganizationCreate(BaseModel):
    """Schema for creating an organization."""
    name: str = Field(..., min_length=1, max_length=255)
    slug: str = Field(..., min_length=1, max_length=100)
    logo_url: Optional[str] = None
    primary_color: str = "#1a56db"
    secondary_color: str = "#7e22ce"
    billing_email: Optional[str] = None
    mfa_required: bool = False


class OrganizationResponse(BaseModel):
    """Response schema for organization."""
    id: int
    name: str
    slug: str
    logo_url: Optional[str] = None
    primary_color: str
    secondary_color: str
    billing_email: Optional[str] = None
    subscription_plan: str
    is_active: bool
    mfa_required: bool
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class UserCreate(BaseModel):
    """Schema for creating a user."""
    organization_id: int
    email: str = Field(..., min_length=5, max_length=255)
    password: str = Field(..., min_length=8)
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    phone: Optional[str] = None
    role: UserRole = UserRole.VIEWER


class UserResponse(BaseModel):
    """Response schema for user."""
    id: int
    organization_id: int
    email: str
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    phone: Optional[str] = None
    role: UserRole
    is_active: bool
    mfa_enabled: bool
    last_login_at: Optional[datetime] = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


# ============================================================================
# AUTHENTICATION SCHEMAS
# ============================================================================

class LoginRequest(BaseModel):
    """Schema for login request."""
    email: str = Field(..., min_length=5, max_length=255)
    password: str = Field(..., min_length=1)


class RegisterRequest(BaseModel):
    """Schema for user registration."""
    email: str = Field(..., min_length=5, max_length=255)
    password: str = Field(..., min_length=8)
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    organization_name: Optional[str] = None


class TokenResponse(BaseModel):
    """Response schema for authentication token."""
    access_token: str
    token_type: str = "bearer"
    expires_in: int
    user: UserResponse


class AuthUserResponse(BaseModel):
    """Response schema for current authenticated user."""
    id: int
    email: str
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    role: UserRole
    organization_id: int
    organization_name: Optional[str] = None
    is_active: bool

    model_config = ConfigDict(from_attributes=True)


class AuditLogResponse(BaseModel):
    """Response schema for audit log entries."""
    id: int
    user_id: Optional[int] = None
    organization_id: Optional[int] = None
    site_id: Optional[int] = None
    action: AuditAction
    entity_type: str
    entity_id: Optional[int] = None
    before_state: Optional[str] = None
    after_state: Optional[str] = None
    ip_address: Optional[str] = None
    correlation_id: Optional[str] = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class FileAssetCreate(BaseModel):
    """Schema for uploading a file."""
    organization_id: Optional[int] = None
    site_id: Optional[int] = None
    file_name: str
    original_name: str
    file_type: Optional[str] = None
    mime_type: Optional[str] = None
    storage_path: str


class FileAssetResponse(BaseModel):
    """Response schema for file assets."""
    id: int
    organization_id: Optional[int] = None
    site_id: Optional[int] = None
    file_name: str
    original_name: str
    file_type: Optional[str] = None
    mime_type: Optional[str] = None
    file_size_bytes: Optional[int] = None
    storage_path: str
    version: int
    status: FileStatus
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class PeriodLockCreate(BaseModel):
    """Schema for creating a period lock."""
    site_id: Optional[int] = None
    period_type: str
    period_start: date
    period_end: date


class PeriodLockResponse(BaseModel):
    """Response schema for period locks."""
    id: int
    site_id: Optional[int] = None
    period_type: str
    period_start: date
    period_end: date
    status: PeriodStatus
    locked_at: Optional[datetime] = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


# ============================================================================
# DATA QUALITY SCHEMAS (Phase 2)
# ============================================================================

class QualityIssueResponse(BaseModel):
    """Response schema for quality issues."""
    id: int
    meter_id: int
    issue_type: QualityIssueType
    severity: str
    timestamp_start: datetime
    timestamp_end: Optional[datetime] = None
    description: Optional[str] = None
    expected_value: Optional[float] = None
    actual_value: Optional[float] = None
    is_resolved: bool
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class MeterQualitySummaryResponse(BaseModel):
    """Response schema for meter quality summaries."""
    id: int
    meter_id: int
    date: date
    expected_readings: int
    actual_readings: int
    coverage_percent: float
    quality_score: float
    issues_count: int
    gaps_minutes: int

    model_config = ConfigDict(from_attributes=True)


class DataQualityDashboard(BaseModel):
    """Dashboard summary for data quality."""
    total_meters: int
    meters_with_issues: int
    average_coverage: float
    average_quality_score: float
    open_issues_count: int
    critical_issues_count: int
    recent_issues: List[QualityIssueResponse]


# ============================================================================
# VIRTUAL METER SCHEMAS (Phase 3)
# ============================================================================

class VirtualMeterComponentCreate(BaseModel):
    """Schema for virtual meter component."""
    meter_id: Optional[int] = None
    weight: float = 1.0
    operator: str = "+"
    allocation_percent: Optional[float] = None


class VirtualMeterCreate(BaseModel):
    """Schema for creating a virtual meter."""
    site_id: int
    name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    meter_type: VirtualMeterType
    expression: Optional[str] = None
    unit: str = "kWh"
    components: List[VirtualMeterComponentCreate] = []


class VirtualMeterResponse(BaseModel):
    """Response schema for virtual meters."""
    id: int
    site_id: int
    name: str
    description: Optional[str] = None
    meter_type: VirtualMeterType
    expression: Optional[str] = None
    unit: str
    is_active: bool
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


# ============================================================================
# PREDICTIVE MAINTENANCE SCHEMAS (Phase 4)
# ============================================================================

class MaintenanceAlertResponse(BaseModel):
    """Response schema for maintenance alerts."""
    id: int
    asset_id: int
    alert_type: MaintenanceRuleType
    severity: str
    title: str
    description: Optional[str] = None
    triggered_value: Optional[float] = None
    threshold_value: Optional[float] = None
    status: str
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class AssetConditionResponse(BaseModel):
    """Response schema for asset condition."""
    id: int
    asset_id: int
    condition: MaintenanceCondition
    health_score: float
    last_inspection_date: Optional[date] = None
    next_maintenance_date: Optional[date] = None
    estimated_remaining_life_years: Optional[float] = None
    notes: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


# ============================================================================
# AI AGENT SCHEMAS (Phase 4)
# ============================================================================

class AgentChatRequest(BaseModel):
    """Request to chat with an AI agent."""
    message: str
    site_id: Optional[int] = None
    agent_type: AgentType = AgentType.ENERGY_ANALYST
    session_id: Optional[int] = None


class AgentChatResponse(BaseModel):
    """Response from AI agent chat."""
    session_id: int
    response: str
    evidence: Optional[Dict[str, Any]] = None
    recommendations: List[Dict[str, Any]] = []


class RecommendationResponse(BaseModel):
    """Response schema for recommendations."""
    id: int
    site_id: int
    agent_type: AgentType
    category: str
    title: str
    description: str
    expected_savings: Optional[float] = None
    confidence_score: Optional[float] = None
    priority: str
    status: str
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


# ============================================================================
# FORECASTING SCHEMAS (Phase 4)
# ============================================================================

class ForecastRequest(BaseModel):
    """Request for generating a forecast."""
    site_id: int
    meter_id: Optional[int] = None
    forecast_type: str = "load"
    horizon_hours: int = 24


class ForecastPointResponse(BaseModel):
    """Response schema for forecast data point."""
    timestamp: datetime
    predicted_value: float
    lower_bound: Optional[float] = None
    upper_bound: Optional[float] = None
    confidence: Optional[float] = None


class ForecastResponse(BaseModel):
    """Response schema for forecast results."""
    job_id: int
    site_id: int
    forecast_type: str
    horizon_hours: int
    status: str
    data: List[ForecastPointResponse] = []


# ============================================================================
# CONTROL SCHEMAS (Phase 4)
# ============================================================================

class ControlRuleCreate(BaseModel):
    """Schema for creating a control rule."""
    site_id: int
    name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    rule_type: ControlRuleType
    trigger_condition: str
    action_type: str
    action_params: Optional[str] = None
    target_asset_id: Optional[int] = None
    requires_approval: bool = True
    requires_mfa: bool = False


class ControlRuleResponse(BaseModel):
    """Response schema for control rules."""
    id: int
    site_id: int
    name: str
    description: Optional[str] = None
    rule_type: ControlRuleType
    trigger_condition: str
    action_type: str
    requires_approval: bool
    is_active: bool
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


class ControlCommandResponse(BaseModel):
    """Response schema for control commands."""
    id: int
    rule_id: Optional[int] = None
    asset_id: int
    command_type: str
    status: str
    safety_gate_status: SafetyGateStatus
    executed_at: Optional[datetime] = None
    result: Optional[str] = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)


# ============================================================================
# PV SIZING SCHEMAS (Phase 3)
# ============================================================================

class PVSizingRequest(BaseModel):
    """Request for PV system sizing calculation."""
    site_id: int
    roof_area_sqm: float = Field(..., gt=0)
    location_latitude: float
    location_longitude: float
    panel_efficiency: float = Field(default=0.20, ge=0.1, le=0.25)
    system_losses: float = Field(default=0.14, ge=0, le=0.3)
    average_monthly_consumption_kwh: float = Field(..., gt=0)
    electricity_rate: float = Field(..., gt=0)
    installation_cost_per_kwp: float = Field(default=1200, gt=0)
    annual_degradation: float = Field(default=0.005, ge=0, le=0.02)
    analysis_years: int = Field(default=25, ge=1, le=30)


class PVSizingResponse(BaseModel):
    """Response for PV sizing calculation."""
    recommended_capacity_kwp: float
    estimated_annual_production_kwh: float
    estimated_annual_savings: float
    estimated_installation_cost: float
    simple_payback_years: float
    co2_offset_tonnes_per_year: float
    roof_utilization_percent: float
    monthly_production: List[float]


def init_db():
    """Initialize database tables."""
    Base.metadata.create_all(bind=engine)


def perform_gap_analysis(db, site_id: int) -> GapAnalysisResult:
    """
    Perform gap analysis for a given site.
    
    Compares the SLD asset tree with connected meters to identify
    unmetered nodes that require monitoring.
    
    Algorithm:
    1. Get all assets for the site
    2. Get all active meters for the site
    3. Find assets that require metering but have no meter
    4. Generate recommendations
    """
    site = db.query(Site).filter(Site.id == site_id).first()
    if not site:
        raise ValueError(f"Site with ID {site_id} not found")

    assets = db.query(Asset).filter(Asset.site_id == site_id).all()
    active_meters = db.query(Meter).filter(
        Meter.site_id == site_id,
        Meter.is_active == 1
    ).all()
    
    metered_asset_ids = {
        meter.asset_id for meter in active_meters if meter.asset_id is not None
    }

    asset_dict = {asset.id: asset for asset in assets}
    assets_requiring_metering = [a for a in assets if a.requires_metering]
    
    unmetered_assets: List[UnmeteredAsset] = []
    critical_unmetered_count = 0

    for asset in assets_requiring_metering:
        if asset.id not in metered_asset_ids:
            path = []
            current = asset
            while current:
                path.insert(0, current.name)
                if current.parent_id:
                    current = asset_dict.get(current.parent_id)
                else:
                    break

            parent_name = None
            if asset.parent_id:
                parent = asset_dict.get(asset.parent_id)
                parent_name = parent.name if parent else None

            unmetered_asset = UnmeteredAsset(
                asset_id=asset.id,
                asset_name=asset.name,
                asset_type=asset.asset_type,
                parent_id=asset.parent_id,
                parent_name=parent_name,
                rated_capacity_kw=asset.rated_capacity_kw,
                is_critical=bool(asset.is_critical),
                hierarchy_path=path
            )
            unmetered_assets.append(unmetered_asset)
            if asset.is_critical:
                critical_unmetered_count += 1

    total_requiring_metering = len(assets_requiring_metering)
    metered_count = total_requiring_metering - len(unmetered_assets)
    coverage_percentage = (
        (metered_count / total_requiring_metering * 100)
        if total_requiring_metering > 0 else 100.0
    )

    recommendations = []
    if critical_unmetered_count > 0:
        recommendations.append(
            f"CRITICAL: {critical_unmetered_count} critical asset(s) are unmetered."
        )
    if coverage_percentage < 50:
        recommendations.append(f"Coverage is very low ({coverage_percentage:.1f}%).")
    elif coverage_percentage < 80:
        recommendations.append(f"Coverage is moderate ({coverage_percentage:.1f}%).")

    return GapAnalysisResult(
        site_id=site_id,
        site_name=site.name,
        total_assets=len(assets),
        metered_assets=metered_count,
        unmetered_assets=len(unmetered_assets),
        coverage_percentage=round(coverage_percentage, 2),
        critical_unmetered_count=critical_unmetered_count,
        unmetered_asset_list=unmetered_assets,
        recommendations=recommendations
    )


def validate_bill(db, bill_id: int) -> BillValidationResult:
    """
    Validate a bill by comparing with meter readings.
    
    Cross-references the bill's total kWh with the sum of
    meter readings for the same period.
    """
    bill = db.query(Bill).filter(Bill.id == bill_id).first()
    if not bill:
        raise ValueError(f"Bill with ID {bill_id} not found")

    period_start = datetime.combine(bill.period_start, datetime.min.time())
    period_end = datetime.combine(bill.period_end, datetime.max.time())

    meters = db.query(Meter).filter(
        Meter.site_id == bill.site_id,
        Meter.is_active == 1
    ).all()

    meter_total_kwh = 0.0
    for meter in meters:
        readings = db.query(MeterReading).filter(
            MeterReading.meter_id == meter.id,
            MeterReading.timestamp >= period_start,
            MeterReading.timestamp <= period_end
        ).all()
        if readings:
            meter_total_kwh += sum(r.energy_kwh for r in readings)

    variance_kwh = bill.total_kwh - meter_total_kwh
    variance_percentage = (
        (variance_kwh / bill.total_kwh * 100) if bill.total_kwh > 0 else 0.0
    )

    is_valid = abs(variance_percentage) <= 2.0

    if is_valid:
        message = f"Bill validated. Variance of {variance_percentage:.2f}% is within tolerance."
    elif abs(variance_percentage) <= 5.0:
        message = f"Minor variance detected ({variance_percentage:.2f}%)."
    else:
        message = f"Significant variance detected ({variance_percentage:.2f}%)."

    bill.is_validated = 1 if is_valid else 0
    bill.validation_variance_pct = variance_percentage
    db.commit()

    return BillValidationResult(
        bill_id=bill_id,
        is_valid=is_valid,
        bill_total_kwh=bill.total_kwh,
        meter_total_kwh=meter_total_kwh,
        variance_kwh=variance_kwh,
        variance_percentage=round(variance_percentage, 2),
        message=message
    )


def calculate_solar_roi(inputs: SolarROIInput) -> SolarROIResult:
    """
    Calculate solar PV system ROI.
    
    Formulas:
    - Year N Production = System Size * kWh/kW * (1 - degradation_rate)^(N-1)
    - Year N Savings = Production_N * Rate * (1 + inflation)^(N-1)
    - Simple Payback = Net Cost / Year 1 Savings
    - NPV = Sum of discounted cash flows
    - IRR = Discount rate that makes NPV = 0
    """
    net_cost = inputs.installation_cost - inputs.incentive_amount
    year_one_production = inputs.system_size_kw * inputs.annual_solar_production_kwh_per_kw
    export_rate = inputs.net_metering_rate or inputs.average_electricity_rate
    discount_rate = 0.06

    annual_projections = []
    cumulative_savings = 0.0
    cumulative_cash_flow = -net_cost
    break_even_year = None

    for year in range(1, inputs.analysis_period_years + 1):
        degradation_factor = (1 - inputs.annual_degradation_rate) ** (year - 1)
        production = year_one_production * degradation_factor
        inflation_factor = (1 + inputs.inflation_rate) ** (year - 1)
        current_rate = inputs.average_electricity_rate * inflation_factor
        
        self_consumption = min(production, inputs.annual_consumption_kwh * degradation_factor)
        export = max(0, production - self_consumption)
        savings = (self_consumption * current_rate) + (export * export_rate * inflation_factor)
        net_annual = savings - inputs.maintenance_cost_annual
        
        cumulative_savings += net_annual
        cumulative_cash_flow += net_annual

        if break_even_year is None and cumulative_cash_flow >= 0:
            break_even_year = year

        annual_projections.append({
            "year": year,
            "production_kwh": round(production, 2),
            "savings": round(net_annual, 2),
            "cumulative_savings": round(cumulative_savings, 2),
            "cumulative_cash_flow": round(cumulative_cash_flow, 2)
        })

    import numpy_financial as npf
    
    year_one_savings = annual_projections[0]["savings"]
    simple_payback = net_cost / year_one_savings if year_one_savings > 0 else float('inf')

    cash_flows = [-net_cost] + [p["savings"] for p in annual_projections]
    npv = npf.npv(discount_rate, cash_flows)
    
    try:
        irr = npf.irr(cash_flows)
        if irr is None or not (-1 < irr < 10):
            irr = 0.0
    except Exception:
        irr = 0.0

    return SolarROIResult(
        system_size_kw=inputs.system_size_kw,
        installation_cost=inputs.installation_cost,
        year_one_production_kwh=round(year_one_production, 2),
        year_one_savings=round(year_one_savings, 2),
        simple_payback_years=round(simple_payback, 2),
        net_present_value=round(npv, 2),
        internal_rate_of_return=round(irr * 100, 2),
        lifetime_savings=round(cumulative_savings, 2),
        break_even_year=break_even_year,
        annual_projections=annual_projections
    )


# ============================================================================
# BESS FINANCIAL ANALYZER (Enterprise Edition)
# ============================================================================

def simulate_bess_operation(inputs: BESSSimulationInput) -> BESSSimulationResult:
    """
    Simulate battery energy storage system (BESS) operation for financial analysis.
    
    Algorithm:
    1. Iterate through 8760 hourly intervals
    2. For each hour: decide to charge (low price) or discharge (high price)
    3. Track arbitrage savings from TOU shifting
    4. Calculate monthly peak reduction for demand charge savings
    5. Project savings over analysis period with degradation
    6. Calculate NPV and IRR using numpy_financial
    
    Peak Shaving Logic:
    - Identify monthly peak demand periods
    - Discharge battery to reduce demand peaks
    - Calculate demand charge savings
    
    Arbitrage Logic:
    - Charge when electricity price is below daily average
    - Discharge when price is above daily average
    """
    import numpy_financial as npf
    
    load_profile = inputs.load_profile_kwh
    tariff_rates = inputs.tariff_rates
    battery_kwh = inputs.battery_capacity_kwh
    battery_kw = inputs.battery_power_kw
    efficiency = inputs.round_trip_efficiency
    dod = inputs.depth_of_discharge
    
    usable_capacity = battery_kwh * dod
    hours_per_year = 8760
    hours_per_month = [744, 672, 744, 720, 744, 720, 744, 744, 720, 744, 720, 744]
    
    soc = usable_capacity * 0.5
    arbitrage_savings = 0.0
    monthly_peaks_original = [0.0] * 12
    monthly_peaks_with_bess = [0.0] * 12
    
    hour_to_month = []
    hour_idx = 0
    for month_idx, hours_in_month in enumerate(hours_per_month):
        for _ in range(hours_in_month):
            if hour_idx < hours_per_year:
                hour_to_month.append(month_idx)
                hour_idx += 1
    
    while len(hour_to_month) < hours_per_year:
        hour_to_month.append(11)
    
    for hour in range(hours_per_year):
        load = load_profile[hour] if hour < len(load_profile) else 0
        rate = tariff_rates[hour] if hour < len(tariff_rates) else 0.1
        month = hour_to_month[hour]
        
        monthly_peaks_original[month] = max(monthly_peaks_original[month], load)
        
        day_start = (hour // 24) * 24
        day_end = min(day_start + 24, hours_per_year)
        day_rates = tariff_rates[day_start:day_end] if day_end <= len(tariff_rates) else [0.1] * 24
        avg_rate = sum(day_rates) / len(day_rates) if day_rates else 0.1
        
        if rate < avg_rate * 0.9 and soc < usable_capacity:
            charge_amount = min(battery_kw, usable_capacity - soc)
            soc += charge_amount
            arbitrage_savings -= charge_amount * rate
        elif rate > avg_rate * 1.1 and soc > 0:
            discharge_amount = min(battery_kw, soc)
            soc -= discharge_amount
            arbitrage_savings += discharge_amount * rate * efficiency
        
        net_load = load - (battery_kw if soc > battery_kw else soc) * 0.3
        monthly_peaks_with_bess[month] = max(monthly_peaks_with_bess[month], max(0, net_load))
    
    monthly_peak_reduction = [
        round(orig - reduced, 2)
        for orig, reduced in zip(monthly_peaks_original, monthly_peaks_with_bess)
    ]
    
    demand_charges = inputs.demand_charges or [15.0] * 12
    peak_shaving_savings = sum(
        reduction * charge
        for reduction, charge in zip(monthly_peak_reduction, demand_charges)
    )
    
    total_savings_year1 = arbitrage_savings + peak_shaving_savings
    
    annual_projections = []
    cash_flows = [-inputs.capex]
    cumulative = -inputs.capex
    
    for year in range(1, inputs.analysis_years + 1):
        degradation_factor = (1 - inputs.degradation_rate) ** (year - 1)
        year_savings = total_savings_year1 * degradation_factor - inputs.opex_annual
        cumulative += year_savings
        cash_flows.append(year_savings)
        
        annual_projections.append({
            "year": year,
            "degradation_factor": round(degradation_factor, 3),
            "gross_savings": round(total_savings_year1 * degradation_factor, 2),
            "net_savings": round(year_savings, 2),
            "cumulative": round(cumulative, 2)
        })
    
    simple_payback = (
        inputs.capex / total_savings_year1
        if total_savings_year1 > 0
        else float('inf')
    )
    
    npv = npf.npv(inputs.discount_rate, cash_flows)
    
    try:
        irr = npf.irr(cash_flows)
        if irr is None or not (-1 < irr < 10):
            irr = None
        else:
            irr = round(irr * 100, 2)
    except Exception:
        irr = None
    
    lifetime_savings = sum(p["net_savings"] for p in annual_projections)
    
    return BESSSimulationResult(
        arbitrage_savings_year1=round(arbitrage_savings, 2),
        peak_shaving_savings_year1=round(peak_shaving_savings, 2),
        total_savings_year1=round(total_savings_year1, 2),
        simple_payback_years=round(simple_payback, 2),
        net_present_value=round(npv, 2),
        internal_rate_of_return=irr,
        lifetime_savings=round(lifetime_savings, 2),
        annual_projections=annual_projections,
        monthly_peak_reduction=monthly_peak_reduction
    )


# ============================================================================
# INTEGRATION LAYER - DATA SOURCES (Enterprise Edition)
# ============================================================================

from abc import ABC, abstractmethod
from typing import Generator


class DataSourceDriver(ABC):
    """Abstract base class for data source drivers."""
    
    @abstractmethod
    def connect(self) -> bool:
        """Establish connection to the data source."""
        pass
    
    @abstractmethod
    def disconnect(self) -> None:
        """Close connection to the data source."""
        pass
    
    @abstractmethod
    def poll(self) -> Generator[MeasurementCreate, None, None]:
        """Poll data from the source and yield normalized measurements."""
        pass
    
    @abstractmethod
    def is_connected(self) -> bool:
        """Check if connection is active."""
        pass


class ModbusTCPDriver(DataSourceDriver):
    """
    Modbus TCP driver for polling data from Modbus devices.
    
    This is a skeleton implementation showing the structure for
    integrating with pymodbus library.
    """
    
    def __init__(
        self,
        data_source_id: int,
        host: str,
        port: int = 502,
        slave_id: int = 1,
        registers: Optional[List[Dict[str, Any]]] = None
    ):
        self.data_source_id = data_source_id
        self.host = host
        self.port = port
        self.slave_id = slave_id
        self.registers = registers or []
        self._client = None
        self._connected = False
    
    def connect(self) -> bool:
        """Establish Modbus TCP connection."""
        try:
            from pymodbus.client import ModbusTcpClient
            
            self._client = ModbusTcpClient(
                host=self.host,
                port=self.port
            )
            self._connected = self._client.connect()
            return self._connected
        except Exception as e:
            self._connected = False
            raise ConnectionError(f"Failed to connect to Modbus device: {e}")
    
    def disconnect(self) -> None:
        """Close Modbus connection."""
        if self._client:
            self._client.close()
        self._connected = False
    
    def is_connected(self) -> bool:
        """Check if Modbus connection is active."""
        return self._connected and self._client is not None
    
    def poll(self) -> Generator[MeasurementCreate, None, None]:
        """
        Poll all configured registers and yield normalized measurements.
        
        Register config example:
        {
            "address": 100,
            "count": 2,
            "type": "holding",
            "data_type": "float32",
            "unit": "kWh",
            "meter_id": 1,
            "scale_factor": 1.0
        }
        """
        if not self.is_connected():
            raise ConnectionError("Not connected to Modbus device")
        
        for reg_config in self.registers:
            try:
                address = reg_config.get("address", 0)
                count = reg_config.get("count", 1)
                reg_type = reg_config.get("type", "holding")
                
                if reg_type == "holding":
                    result = self._client.read_holding_registers(
                        address=address,
                        count=count,
                        slave=self.slave_id
                    )
                elif reg_type == "input":
                    result = self._client.read_input_registers(
                        address=address,
                        count=count,
                        slave=self.slave_id
                    )
                else:
                    continue
                
                if result.isError():
                    continue
                
                raw_value = float(result.registers[0]) if result.registers else 0.0
                scale_factor = reg_config.get("scale_factor", 1.0)
                value = raw_value * scale_factor
                
                yield MeasurementCreate(
                    data_source_id=self.data_source_id,
                    meter_id=reg_config.get("meter_id"),
                    timestamp=datetime.utcnow(),
                    value=value,
                    unit=reg_config.get("unit", "kWh"),
                    quality="good",
                    raw_value=raw_value
                )
            except Exception:
                yield MeasurementCreate(
                    data_source_id=self.data_source_id,
                    meter_id=reg_config.get("meter_id"),
                    timestamp=datetime.utcnow(),
                    value=0.0,
                    unit=reg_config.get("unit", "kWh"),
                    quality="bad",
                    raw_value=None
                )


class CSVImportDriver(DataSourceDriver):
    """CSV import driver for bulk data import from legacy systems."""
    
    def __init__(self, data_source_id: int, file_path: str):
        self.data_source_id = data_source_id
        self.file_path = file_path
        self._connected = False
    
    def connect(self) -> bool:
        """Verify CSV file exists and is readable."""
        import os
        self._connected = os.path.exists(self.file_path)
        return self._connected
    
    def disconnect(self) -> None:
        """No connection to close for CSV."""
        self._connected = False
    
    def is_connected(self) -> bool:
        return self._connected
    
    def poll(self) -> Generator[MeasurementCreate, None, None]:
        """Parse CSV and yield normalized measurements."""
        import csv
        
        with open(self.file_path, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                try:
                    yield MeasurementCreate(
                        data_source_id=self.data_source_id,
                        meter_id=int(row.get("meter_id", 0)) or None,
                        timestamp=datetime.fromisoformat(row["timestamp"]),
                        value=float(row["value"]),
                        unit=row.get("unit", "kWh"),
                        quality=row.get("quality", "good"),
                        raw_value=float(row.get("raw_value", row["value"]))
                    )
                except (KeyError, ValueError):
                    continue


class DataNormalizer:
    """
    Service that normalizes data from all sources into standard Measurement format.
    
    Responsibilities:
    - Unit conversion (e.g., MWh to kWh)
    - Data quality validation
    - Timestamp normalization (timezone handling)
    - Outlier detection
    """
    
    UNIT_CONVERSIONS = {
        ("MWh", "kWh"): 1000.0,
        ("kWh", "MWh"): 0.001,
        ("MW", "kW"): 1000.0,
        ("kW", "MW"): 0.001,
        ("W", "kW"): 0.001,
        ("kW", "W"): 1000.0,
    }
    
    @classmethod
    def normalize_unit(cls, value: float, from_unit: str, to_unit: str) -> float:
        """Convert value between units."""
        if from_unit == to_unit:
            return value
        
        conversion_factor = cls.UNIT_CONVERSIONS.get((from_unit, to_unit))
        if conversion_factor:
            return value * conversion_factor
        
        return value
    
    @classmethod
    def validate_quality(cls, value: float, min_val: float = 0, max_val: float = 1e9) -> str:
        """Validate measurement quality based on value range."""
        if value < min_val or value > max_val:
            return "suspect"
        return "good"
    
    @classmethod
    def normalize_measurement(
        cls,
        measurement: MeasurementCreate,
        target_unit: str = "kWh"
    ) -> MeasurementCreate:
        """Normalize a measurement to standard format."""
        normalized_value = cls.normalize_unit(
            measurement.value,
            measurement.unit,
            target_unit
        )
        quality = cls.validate_quality(normalized_value)
        
        return MeasurementCreate(
            data_source_id=measurement.data_source_id,
            meter_id=measurement.meter_id,
            timestamp=measurement.timestamp,
            value=normalized_value,
            unit=target_unit,
            quality=quality,
            raw_value=measurement.raw_value
        )


# ============================================================================
# TENANT BILLING ENGINE (Enterprise Edition)
# ============================================================================

def calculate_tenant_monthly_bill(
    db,
    tenant_id: int,
    billing_period_start: date,
    billing_period_end: date,
    tax_rate: float = 0.0
) -> Invoice:
    """
    Calculate monthly bill for a tenant based on their lease contract and consumption.
    
    Algorithm:
    1. Get active lease contract for tenant
    2. Query meter readings for billing period
    3. Calculate line items:
       - Energy charge = consumption * rate_per_kwh
       - Demand charge = peak_demand * demand_charge_per_kw
       - Fixed fee = fixed_monthly_fee
       - Loss charge = energy_charge * loss_factor_percent
    4. Apply minimum monthly charge if applicable
    5. Calculate tax and total
    """
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise ValueError(f"Tenant {tenant_id} not found")
    
    lease = db.query(LeaseContract).filter(
        LeaseContract.tenant_id == tenant_id,
        LeaseContract.is_active == 1,
        LeaseContract.start_date <= billing_period_end,
        (LeaseContract.end_date.is_(None) | (LeaseContract.end_date >= billing_period_start))
    ).first()
    
    if not lease:
        raise ValueError(f"No active lease contract for tenant {tenant_id}")
    
    consumption_kwh = 0.0
    peak_demand_kw = 0.0
    
    if lease.meter_id:
        readings = db.query(MeterReading).filter(
            MeterReading.meter_id == lease.meter_id,
            MeterReading.reading_date >= billing_period_start,
            MeterReading.reading_date <= billing_period_end
        ).all()
        
        consumption_kwh = sum(r.energy_kwh for r in readings)
        peak_demand_kw = max((r.demand_kw for r in readings if r.demand_kw), default=0.0)
    
    energy_charge = consumption_kwh * lease.rate_per_kwh
    demand_charge = peak_demand_kw * lease.demand_charge_per_kw
    fixed_fee = lease.fixed_monthly_fee
    loss_charge = energy_charge * (lease.loss_factor_percent / 100.0)
    
    subtotal = energy_charge + demand_charge + fixed_fee + loss_charge
    
    if subtotal < lease.min_monthly_charge:
        subtotal = lease.min_monthly_charge
    
    tax_amount = subtotal * tax_rate
    total_amount = subtotal + tax_amount
    
    invoice_number = f"INV-{tenant_id}-{billing_period_start.strftime('%Y%m')}"
    
    invoice = Invoice(
        tenant_id=tenant_id,
        lease_contract_id=lease.id,
        invoice_number=invoice_number,
        billing_period_start=billing_period_start,
        billing_period_end=billing_period_end,
        consumption_kwh=consumption_kwh,
        peak_demand_kw=peak_demand_kw,
        energy_charge=energy_charge,
        demand_charge=demand_charge,
        fixed_fee=fixed_fee,
        loss_charge=loss_charge,
        subtotal=subtotal,
        tax_amount=tax_amount,
        total_amount=total_amount,
        status=InvoiceStatus.DRAFT,
        due_date=billing_period_end + timedelta(days=30)
    )
    
    db.add(invoice)
    db.commit()
    db.refresh(invoice)
    
    return invoice


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan events."""
    init_db()
    yield


app = FastAPI(
    title="SAVE-IT.AI",
    description="AI-driven energy management platform for B2B clients",
    version="0.1.0",
    lifespan=lifespan
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/")
def root():
    """Root endpoint."""
    return {
        "name": "SAVE-IT.AI",
        "version": "0.1.0",
        "description": "AI-driven energy management platform",
        "docs_url": "/docs",
        "api_prefix": "/api/v1"
    }


@app.get("/health")
def health_check():
    """Health check endpoint."""
    return {"status": "healthy"}


from fastapi import Depends, HTTPException, Query

@app.get("/api/v1/sites", response_model=List[SiteResponse], tags=["sites"])
def list_sites(skip: int = 0, limit: int = 100, db=Depends(get_db)):
    sites = db.query(Site).offset(skip).limit(limit).all()
    return sites


@app.get("/api/v1/sites/{site_id}", response_model=SiteResponse, tags=["sites"])
def get_site(site_id: int, db=Depends(get_db)):
    site = db.query(Site).filter(Site.id == site_id).first()
    if not site:
        raise HTTPException(status_code=404, detail="Site not found")
    return site


@app.post("/api/v1/sites", response_model=SiteResponse, tags=["sites"])
def create_site(site: SiteCreate, db=Depends(get_db)):
    db_site = Site(**site.model_dump())
    db.add(db_site)
    db.commit()
    db.refresh(db_site)
    return db_site


@app.put("/api/v1/sites/{site_id}", response_model=SiteResponse, tags=["sites"])
def update_site(site_id: int, site: SiteUpdate, db=Depends(get_db)):
    db_site = db.query(Site).filter(Site.id == site_id).first()
    if not db_site:
        raise HTTPException(status_code=404, detail="Site not found")
    update_data = site.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_site, field, value)
    db.commit()
    db.refresh(db_site)
    return db_site


@app.delete("/api/v1/sites/{site_id}", tags=["sites"])
def delete_site(site_id: int, db=Depends(get_db)):
    db_site = db.query(Site).filter(Site.id == site_id).first()
    if not db_site:
        raise HTTPException(status_code=404, detail="Site not found")
    db.delete(db_site)
    db.commit()
    return {"message": "Site deleted successfully"}


@app.get("/api/v1/assets", response_model=List[AssetResponse], tags=["assets"])
def list_assets(site_id: Optional[int] = None, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    query = db.query(Asset)
    if site_id:
        query = query.filter(Asset.site_id == site_id)
    return query.offset(skip).limit(limit).all()


@app.get("/api/v1/assets/tree/{site_id}", response_model=List[AssetTreeNode], tags=["assets"])
def get_asset_tree(site_id: int, db=Depends(get_db)):
    assets = db.query(Asset).filter(Asset.site_id == site_id).all()
    
    def build_tree(parent_id: Optional[int] = None) -> List[AssetTreeNode]:
        children = [a for a in assets if a.parent_id == parent_id]
        return [
            AssetTreeNode(
                id=asset.id,
                name=asset.name,
                asset_type=asset.asset_type,
                has_meter=asset.meter is not None,
                meter_id=asset.meter.meter_id if asset.meter else None,
                children=build_tree(asset.id)
            )
            for asset in children
        ]
    
    return build_tree(None)


@app.get("/api/v1/assets/{asset_id}", response_model=AssetResponse, tags=["assets"])
def get_asset(asset_id: int, db=Depends(get_db)):
    asset = db.query(Asset).filter(Asset.id == asset_id).first()
    if not asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    return asset


@app.post("/api/v1/assets", response_model=AssetResponse, tags=["assets"])
def create_asset(asset: AssetCreate, db=Depends(get_db)):
    db_asset = Asset(
        site_id=asset.site_id,
        parent_id=asset.parent_id,
        name=asset.name,
        asset_type=asset.asset_type,
        description=asset.description,
        rated_capacity_kw=asset.rated_capacity_kw,
        rated_voltage=asset.rated_voltage,
        rated_current=asset.rated_current,
        is_critical=1 if asset.is_critical else 0,
        requires_metering=1 if asset.requires_metering else 0
    )
    db.add(db_asset)
    db.commit()
    db.refresh(db_asset)
    return db_asset


@app.delete("/api/v1/assets/{asset_id}", tags=["assets"])
def delete_asset(asset_id: int, db=Depends(get_db)):
    db_asset = db.query(Asset).filter(Asset.id == asset_id).first()
    if not db_asset:
        raise HTTPException(status_code=404, detail="Asset not found")
    db.delete(db_asset)
    db.commit()
    return {"message": "Asset deleted successfully"}


@app.get("/api/v1/meters", response_model=List[MeterResponse], tags=["meters"])
def list_meters(site_id: Optional[int] = None, active_only: bool = True, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    query = db.query(Meter)
    if site_id:
        query = query.filter(Meter.site_id == site_id)
    if active_only:
        query = query.filter(Meter.is_active == 1)
    return query.offset(skip).limit(limit).all()


@app.get("/api/v1/meters/{meter_id}", response_model=MeterResponse, tags=["meters"])
def get_meter(meter_id: int, db=Depends(get_db)):
    meter = db.query(Meter).filter(Meter.id == meter_id).first()
    if not meter:
        raise HTTPException(status_code=404, detail="Meter not found")
    return meter


@app.post("/api/v1/meters", response_model=MeterResponse, tags=["meters"])
def create_meter(meter: MeterCreate, db=Depends(get_db)):
    existing = db.query(Meter).filter(Meter.meter_id == meter.meter_id).first()
    if existing:
        raise HTTPException(status_code=400, detail="Meter ID already exists")
    db_meter = Meter(
        site_id=meter.site_id,
        asset_id=meter.asset_id,
        meter_id=meter.meter_id,
        name=meter.name,
        description=meter.description,
        manufacturer=meter.manufacturer,
        model=meter.model,
        serial_number=meter.serial_number,
        is_active=1 if meter.is_active else 0,
        is_bidirectional=1 if meter.is_bidirectional else 0
    )
    db.add(db_meter)
    db.commit()
    db.refresh(db_meter)
    return db_meter


@app.delete("/api/v1/meters/{meter_id}", tags=["meters"])
def delete_meter(meter_id: int, db=Depends(get_db)):
    db_meter = db.query(Meter).filter(Meter.id == meter_id).first()
    if not db_meter:
        raise HTTPException(status_code=404, detail="Meter not found")
    db.delete(db_meter)
    db.commit()
    return {"message": "Meter deleted successfully"}


@app.get("/api/v1/meters/{meter_id}/readings", response_model=List[MeterReadingResponse], tags=["meters"])
def get_meter_readings(
    meter_id: int,
    start_time: Optional[datetime] = Query(None),
    end_time: Optional[datetime] = Query(None),
    limit: int = 1000,
    db=Depends(get_db)
):
    meter = db.query(Meter).filter(Meter.id == meter_id).first()
    if not meter:
        raise HTTPException(status_code=404, detail="Meter not found")
    query = db.query(MeterReading).filter(MeterReading.meter_id == meter_id)
    if start_time:
        query = query.filter(MeterReading.timestamp >= start_time)
    if end_time:
        query = query.filter(MeterReading.timestamp <= end_time)
    return query.order_by(MeterReading.timestamp.desc()).limit(limit).all()


@app.post("/api/v1/meters/readings", response_model=MeterReadingResponse, tags=["meters"])
def create_meter_reading(reading: MeterReadingCreate, db=Depends(get_db)):
    meter = db.query(Meter).filter(Meter.id == reading.meter_id).first()
    if not meter:
        raise HTTPException(status_code=404, detail="Meter not found")
    db_reading = MeterReading(**reading.model_dump())
    db.add(db_reading)
    db.commit()
    db.refresh(db_reading)
    return db_reading


@app.get("/api/v1/bills", response_model=List[BillResponse], tags=["bills"])
def list_bills(site_id: Optional[int] = None, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    query = db.query(Bill)
    if site_id:
        query = query.filter(Bill.site_id == site_id)
    return query.order_by(Bill.period_start.desc()).offset(skip).limit(limit).all()


@app.get("/api/v1/bills/{bill_id}", response_model=BillResponse, tags=["bills"])
def get_bill(bill_id: int, db=Depends(get_db)):
    bill = db.query(Bill).filter(Bill.id == bill_id).first()
    if not bill:
        raise HTTPException(status_code=404, detail="Bill not found")
    return bill


@app.post("/api/v1/bills", response_model=BillResponse, tags=["bills"])
def create_bill(bill: BillCreate, db=Depends(get_db)):
    bill_data = bill.model_dump(exclude={'line_items'})
    db_bill = Bill(**bill_data)
    db.add(db_bill)
    db.commit()
    db.refresh(db_bill)
    for item in bill.line_items:
        db_item = BillLineItem(bill_id=db_bill.id, **item.model_dump())
        db.add(db_item)
    db.commit()
    db.refresh(db_bill)
    return db_bill


@app.post("/api/v1/bills/{bill_id}/validate", response_model=BillValidationResult, tags=["bills"])
def validate_bill_endpoint(bill_id: int, db=Depends(get_db)):
    try:
        return validate_bill(db, bill_id)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


@app.delete("/api/v1/bills/{bill_id}", tags=["bills"])
def delete_bill(bill_id: int, db=Depends(get_db)):
    db_bill = db.query(Bill).filter(Bill.id == bill_id).first()
    if not db_bill:
        raise HTTPException(status_code=404, detail="Bill not found")
    db.delete(db_bill)
    db.commit()
    return {"message": "Bill deleted successfully"}


@app.get("/api/v1/tariffs", response_model=List[TariffResponse], tags=["tariffs"])
def list_tariffs(site_id: Optional[int] = None, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    """List all tariffs, optionally filtered by site."""
    query = db.query(Tariff)
    if site_id:
        query = query.filter(Tariff.site_id == site_id)
    return query.offset(skip).limit(limit).all()


@app.post("/api/v1/tariffs", response_model=TariffResponse, tags=["tariffs"])
def create_tariff(tariff: TariffCreate, db=Depends(get_db)):
    """Create a new tariff schedule."""
    tariff_data = tariff.model_dump()
    db_tariff = Tariff(**{k: v for k, v in tariff_data.items() if hasattr(Tariff, k)})
    db.add(db_tariff)
    db.commit()
    db.refresh(db_tariff)
    return db_tariff


@app.get("/api/v1/analysis/gap-analysis/{site_id}", response_model=GapAnalysisResult, tags=["analysis"])
def run_gap_analysis(site_id: int, db=Depends(get_db)):
    """Run gap analysis comparing SLD assets vs connected meters."""
    try:
        return perform_gap_analysis(db, site_id)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


@app.post("/api/v1/analysis/solar-roi", response_model=SolarROIResult, tags=["analysis"])
def calculate_solar_roi_endpoint(inputs: SolarROIInput):
    """Calculate solar PV system ROI with detailed financial projections."""
    return calculate_solar_roi(inputs)


# ============================================================================
# ENTERPRISE EDITION ENDPOINTS
# ============================================================================

@app.post("/api/v1/analysis/bess-simulation", response_model=BESSSimulationResult, tags=["analysis"])
def run_bess_simulation(inputs: BESSSimulationInput):
    """
    Run BESS financial simulation with TOU arbitrage and peak shaving analysis.
    
    Requires 8760 hourly values for load profile and tariff rates.
    Returns NPV, IRR, payback period, and monthly savings breakdown.
    """
    if len(inputs.load_profile_kwh) != 8760:
        raise HTTPException(
            status_code=400,
            detail=f"Load profile must have 8760 hourly values, got {len(inputs.load_profile_kwh)}"
        )
    if len(inputs.tariff_rates) != 8760:
        raise HTTPException(
            status_code=400,
            detail=f"Tariff rates must have 8760 hourly values, got {len(inputs.tariff_rates)}"
        )
    return simulate_bess_operation(inputs)


@app.post("/api/v1/tenants", response_model=TenantResponse, tags=["tenants"])
def create_tenant(tenant: TenantCreate, db=Depends(get_db)):
    """Create a new tenant for sub-billing."""
    db_tenant = Tenant(**tenant.model_dump())
    db.add(db_tenant)
    db.commit()
    db.refresh(db_tenant)
    return db_tenant


@app.get("/api/v1/tenants", response_model=List[TenantResponse], tags=["tenants"])
def list_tenants(site_id: Optional[int] = None, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    """List all tenants, optionally filtered by site."""
    query = db.query(Tenant)
    if site_id:
        query = query.filter(Tenant.site_id == site_id)
    return query.offset(skip).limit(limit).all()


@app.get("/api/v1/tenants/{tenant_id}", response_model=TenantResponse, tags=["tenants"])
def get_tenant(tenant_id: int, db=Depends(get_db)):
    """Get tenant by ID."""
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise HTTPException(status_code=404, detail="Tenant not found")
    return tenant


@app.post("/api/v1/lease-contracts", response_model=LeaseContractResponse, tags=["tenants"])
def create_lease_contract(contract: LeaseContractCreate, db=Depends(get_db)):
    """Create a new lease contract for a tenant."""
    db_contract = LeaseContract(**contract.model_dump())
    db.add(db_contract)
    db.commit()
    db.refresh(db_contract)
    return db_contract


@app.get("/api/v1/tenants/{tenant_id}/contracts", response_model=List[LeaseContractResponse], tags=["tenants"])
def list_tenant_contracts(tenant_id: int, db=Depends(get_db)):
    """List all lease contracts for a tenant."""
    return db.query(LeaseContract).filter(LeaseContract.tenant_id == tenant_id).all()


@app.post("/api/v1/tenants/{tenant_id}/generate-invoice", response_model=InvoiceResponse, tags=["billing"])
def generate_tenant_invoice(
    tenant_id: int,
    billing_start: date,
    billing_end: date,
    tax_rate: float = 0.0,
    db=Depends(get_db)
):
    """Generate a monthly invoice for a tenant."""
    try:
        return calculate_tenant_monthly_bill(db, tenant_id, billing_start, billing_end, tax_rate)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))


@app.get("/api/v1/invoices", response_model=List[InvoiceResponse], tags=["billing"])
def list_invoices(tenant_id: Optional[int] = None, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    """List all invoices, optionally filtered by tenant."""
    query = db.query(Invoice)
    if tenant_id:
        query = query.filter(Invoice.tenant_id == tenant_id)
    return query.order_by(Invoice.created_at.desc()).offset(skip).limit(limit).all()


@app.get("/api/v1/invoices/{invoice_id}", response_model=InvoiceResponse, tags=["billing"])
def get_invoice(invoice_id: int, db=Depends(get_db)):
    """Get invoice by ID."""
    invoice = db.query(Invoice).filter(Invoice.id == invoice_id).first()
    if not invoice:
        raise HTTPException(status_code=404, detail="Invoice not found")
    return invoice


@app.post("/api/v1/data-sources", response_model=DataSourceResponse, tags=["integrations"])
def create_data_source(source: DataSourceCreate, db=Depends(get_db)):
    """Create a new data source for meter integration."""
    db_source = DataSource(**source.model_dump())
    db.add(db_source)
    db.commit()
    db.refresh(db_source)
    return db_source


@app.get("/api/v1/data-sources", response_model=List[DataSourceResponse], tags=["integrations"])
def list_data_sources(site_id: Optional[int] = None, skip: int = 0, limit: int = 100, db=Depends(get_db)):
    """List all data sources, optionally filtered by site."""
    query = db.query(DataSource)
    if site_id:
        query = query.filter(DataSource.site_id == site_id)
    return query.offset(skip).limit(limit).all()


@app.get("/api/v1/data-sources/{source_id}", response_model=DataSourceResponse, tags=["integrations"])
def get_data_source(source_id: int, db=Depends(get_db)):
    """Get data source by ID."""
    source = db.query(DataSource).filter(DataSource.id == source_id).first()
    if not source:
        raise HTTPException(status_code=404, detail="Data source not found")
    return source


@app.get("/api/v1/notifications", response_model=List[NotificationResponse], tags=["notifications"])
def list_notifications(site_id: Optional[int] = None, unread_only: bool = False, skip: int = 0, limit: int = 50, db=Depends(get_db)):
    query = db.query(Notification)
    if site_id:
        query = query.filter(Notification.site_id == site_id)
    if unread_only:
        query = query.filter(Notification.is_read == 0)
    return query.order_by(Notification.created_at.desc()).offset(skip).limit(limit).all()


@app.get("/api/v1/notifications/{notification_id}", response_model=NotificationResponse, tags=["notifications"])
def get_notification(notification_id: int, db=Depends(get_db)):
    notification = db.query(Notification).filter(Notification.id == notification_id).first()
    if not notification:
        raise HTTPException(status_code=404, detail="Notification not found")
    return notification


@app.post("/api/v1/notifications/{notification_id}/read", response_model=NotificationResponse, tags=["notifications"])
def mark_notification_read(notification_id: int, db=Depends(get_db)):
    notification = db.query(Notification).filter(Notification.id == notification_id).first()
    if not notification:
        raise HTTPException(status_code=404, detail="Notification not found")
    notification.is_read = 1
    db.commit()
    return notification


@app.post("/api/v1/notifications/{notification_id}/resolve", response_model=NotificationResponse, tags=["notifications"])
def mark_notification_resolved(notification_id: int, db=Depends(get_db)):
    notification = db.query(Notification).filter(Notification.id == notification_id).first()
    if not notification:
        raise HTTPException(status_code=404, detail="Notification not found")
    notification.is_resolved = 1
    notification.resolved_at = datetime.utcnow()
    db.commit()
    return notification


from fastapi.responses import StreamingResponse
from io import BytesIO
import openpyxl
from openpyxl.styles import Font, PatternFill, Alignment
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle


class CarbonEmission(Base):
    """Carbon emission tracking for ESG reporting."""
    __tablename__ = "carbon_emissions"

    id = Column(Integer, primary_key=True, index=True)
    site_id = Column(Integer, ForeignKey("sites.id"), nullable=False, index=True)
    year = Column(Integer, nullable=False)
    month = Column(Integer, nullable=False)
    scope1_kg_co2 = Column(Float, default=0)
    scope2_kg_co2 = Column(Float, default=0)
    scope3_kg_co2 = Column(Float, default=0)
    energy_kwh = Column(Float, default=0)
    emission_factor = Column(Float, default=0.5)
    created_at = Column(DateTime, default=datetime.utcnow)

    site = relationship("Site")


class CarbonEmissionCreate(BaseModel):
    site_id: int
    year: int
    month: int
    scope1_kg_co2: float = 0
    scope2_kg_co2: float = 0
    scope3_kg_co2: float = 0
    energy_kwh: float = 0
    emission_factor: float = 0.5


class CarbonEmissionResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    id: int
    site_id: int
    year: int
    month: int
    scope1_kg_co2: float
    scope2_kg_co2: float
    scope3_kg_co2: float
    energy_kwh: float
    emission_factor: float
    created_at: datetime


@app.post("/api/v1/carbon-emissions", response_model=CarbonEmissionResponse, tags=["esg"])
def create_carbon_emission(emission: CarbonEmissionCreate, db=Depends(get_db)):
    """Create carbon emission record for ESG tracking."""
    db_emission = CarbonEmission(**emission.model_dump())
    db.add(db_emission)
    db.commit()
    db.refresh(db_emission)
    return db_emission


@app.get("/api/v1/carbon-emissions", response_model=List[CarbonEmissionResponse], tags=["esg"])
def list_carbon_emissions(site_id: Optional[int] = None, year: Optional[int] = None, db=Depends(get_db)):
    """List carbon emissions with optional filters."""
    query = db.query(CarbonEmission)
    if site_id:
        query = query.filter(CarbonEmission.site_id == site_id)
    if year:
        query = query.filter(CarbonEmission.year == year)
    return query.order_by(CarbonEmission.year.desc(), CarbonEmission.month.desc()).all()


@app.get("/api/v1/carbon-emissions/summary", tags=["esg"])
def get_carbon_summary(site_id: Optional[int] = None, year: Optional[int] = None, db=Depends(get_db)):
    """Get carbon emission summary for ESG reporting."""
    query = db.query(CarbonEmission)
    if site_id:
        query = query.filter(CarbonEmission.site_id == site_id)
    if year:
        query = query.filter(CarbonEmission.year == year)
    
    emissions = query.all()
    total_scope1 = sum(e.scope1_kg_co2 for e in emissions)
    total_scope2 = sum(e.scope2_kg_co2 for e in emissions)
    total_scope3 = sum(e.scope3_kg_co2 for e in emissions)
    total_energy = sum(e.energy_kwh for e in emissions)
    
    return {
        "total_scope1_kg_co2": total_scope1,
        "total_scope2_kg_co2": total_scope2,
        "total_scope3_kg_co2": total_scope3,
        "total_emissions_kg_co2": total_scope1 + total_scope2 + total_scope3,
        "total_energy_kwh": total_energy,
        "emission_intensity": (total_scope1 + total_scope2) / total_energy if total_energy > 0 else 0,
        "record_count": len(emissions)
    }


@app.get("/api/v1/export/sites", tags=["export"])
def export_sites_excel(db=Depends(get_db)):
    """Export sites to Excel file."""
    sites = db.query(Site).all()
    
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Sites"
    
    headers = ["ID", "Name", "Address", "City", "Country", "Timezone", "Created At"]
    header_fill = PatternFill(start_color="1E40AF", end_color="1E40AF", fill_type="solid")
    header_font = Font(color="FFFFFF", bold=True)
    
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=1, column=col, value=header)
        cell.fill = header_fill
        cell.font = header_font
        cell.alignment = Alignment(horizontal="center")
    
    for row, site in enumerate(sites, 2):
        ws.cell(row=row, column=1, value=site.id)
        ws.cell(row=row, column=2, value=site.name)
        ws.cell(row=row, column=3, value=site.address or "")
        ws.cell(row=row, column=4, value=site.city or "")
        ws.cell(row=row, column=5, value=site.country or "")
        ws.cell(row=row, column=6, value=site.timezone)
        ws.cell(row=row, column=7, value=str(site.created_at))
    
    for col in ws.columns:
        max_length = max(len(str(cell.value or "")) for cell in col)
        ws.column_dimensions[col[0].column_letter].width = min(max_length + 2, 50)
    
    output = BytesIO()
    wb.save(output)
    output.seek(0)
    
    return StreamingResponse(
        output,
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": "attachment; filename=sites_export.xlsx"}
    )


@app.get("/api/v1/export/meters", tags=["export"])
def export_meters_excel(site_id: Optional[int] = None, db=Depends(get_db)):
    """Export meters to Excel file."""
    query = db.query(Meter)
    if site_id:
        query = query.filter(Meter.site_id == site_id)
    meters = query.all()
    
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Meters"
    
    headers = ["ID", "Meter ID", "Name", "Site ID", "Manufacturer", "Model", "Serial Number", "Active"]
    header_fill = PatternFill(start_color="10B981", end_color="10B981", fill_type="solid")
    header_font = Font(color="FFFFFF", bold=True)
    
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=1, column=col, value=header)
        cell.fill = header_fill
        cell.font = header_font
    
    for row, meter in enumerate(meters, 2):
        ws.cell(row=row, column=1, value=meter.id)
        ws.cell(row=row, column=2, value=meter.meter_id)
        ws.cell(row=row, column=3, value=meter.name)
        ws.cell(row=row, column=4, value=meter.site_id)
        ws.cell(row=row, column=5, value=meter.manufacturer or "")
        ws.cell(row=row, column=6, value=meter.model or "")
        ws.cell(row=row, column=7, value=meter.serial_number or "")
        ws.cell(row=row, column=8, value="Yes" if meter.is_active else "No")
    
    output = BytesIO()
    wb.save(output)
    output.seek(0)
    
    return StreamingResponse(
        output,
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": "attachment; filename=meters_export.xlsx"}
    )


@app.get("/api/v1/export/bills", tags=["export"])
def export_bills_excel(site_id: Optional[int] = None, db=Depends(get_db)):
    """Export bills to Excel file."""
    query = db.query(Bill)
    if site_id:
        query = query.filter(Bill.site_id == site_id)
    bills = query.all()
    
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Bills"
    
    headers = ["ID", "Site ID", "Utility Provider", "Bill Period Start", "Bill Period End", 
               "Total kWh", "Peak kW", "Total Amount", "Currency", "Validated"]
    header_fill = PatternFill(start_color="F59E0B", end_color="F59E0B", fill_type="solid")
    header_font = Font(color="FFFFFF", bold=True)
    
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=1, column=col, value=header)
        cell.fill = header_fill
        cell.font = header_font
    
    for row, bill in enumerate(bills, 2):
        ws.cell(row=row, column=1, value=bill.id)
        ws.cell(row=row, column=2, value=bill.site_id)
        ws.cell(row=row, column=3, value=bill.utility_provider or "")
        ws.cell(row=row, column=4, value=str(bill.period_start))
        ws.cell(row=row, column=5, value=str(bill.period_end))
        ws.cell(row=row, column=6, value=bill.total_kwh or 0)
        ws.cell(row=row, column=7, value=bill.peak_kw or 0)
        ws.cell(row=row, column=8, value=bill.total_amount or 0)
        ws.cell(row=row, column=9, value=bill.currency)
        ws.cell(row=row, column=10, value="Yes" if bill.is_validated else "No")
    
    output = BytesIO()
    wb.save(output)
    output.seek(0)
    
    return StreamingResponse(
        output,
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": "attachment; filename=bills_export.xlsx"}
    )


@app.get("/api/v1/reports/site-summary/{site_id}", tags=["reports"])
def generate_site_report_pdf(site_id: int, db=Depends(get_db)):
    """Generate PDF report for a site."""
    site = db.query(Site).filter(Site.id == site_id).first()
    if not site:
        raise HTTPException(status_code=404, detail="Site not found")
    
    meters = db.query(Meter).filter(Meter.site_id == site_id).all()
    bills = db.query(Bill).filter(Bill.site_id == site_id).order_by(Bill.period_end.desc()).limit(12).all()
    assets = db.query(Asset).filter(Asset.site_id == site_id).all()
    
    output = BytesIO()
    doc = SimpleDocTemplate(output, pagesize=A4)
    styles = getSampleStyleSheet()
    story = []
    
    title_style = ParagraphStyle('Title', parent=styles['Title'], fontSize=24, textColor=colors.HexColor('#1E40AF'))
    story.append(Paragraph(f"SAVE-IT.AI - Site Report", title_style))
    story.append(Spacer(1, 20))
    story.append(Paragraph(f"<b>Site:</b> {site.name}", styles['Normal']))
    story.append(Paragraph(f"<b>Address:</b> {site.address or 'N/A'}, {site.city or ''}, {site.country or ''}", styles['Normal']))
    story.append(Paragraph(f"<b>Generated:</b> {datetime.now().strftime('%Y-%m-%d %H:%M')}", styles['Normal']))
    story.append(Spacer(1, 30))
    
    story.append(Paragraph("Site Summary", styles['Heading2']))
    summary_data = [
        ["Metric", "Value"],
        ["Total Assets", str(len(assets))],
        ["Active Meters", str(len([m for m in meters if m.is_active]))],
        ["Total Bills", str(len(bills))],
        ["Total Capacity (kW)", str(sum(a.rated_capacity_kw or 0 for a in assets))],
    ]
    summary_table = Table(summary_data, colWidths=[200, 200])
    summary_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#1E40AF')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('GRID', (0, 0), (-1, -1), 1, colors.grey),
    ]))
    story.append(summary_table)
    story.append(Spacer(1, 30))
    
    if bills:
        story.append(Paragraph("Recent Bills", styles['Heading2']))
        bill_data = [["Period", "kWh", "Peak kW", "Amount", "Validated"]]
        for bill in bills[:6]:
            bill_data.append([
                f"{bill.period_start} - {bill.period_end}",
                f"{bill.total_kwh:,.0f}" if bill.total_kwh else "N/A",
                f"{bill.peak_kw:,.1f}" if bill.peak_kw else "N/A",
                f"{bill.currency} {bill.total_amount:,.2f}" if bill.total_amount else "N/A",
                "Yes" if bill.is_validated else "No"
            ])
        bill_table = Table(bill_data, colWidths=[120, 80, 80, 100, 70])
        bill_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#10B981')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 9),
            ('GRID', (0, 0), (-1, -1), 1, colors.grey),
        ]))
        story.append(bill_table)
    
    doc.build(story)
    output.seek(0)
    
    return StreamingResponse(
        output,
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename=site_{site_id}_report.pdf"}
    )


@app.get("/api/v1/reports/energy-analysis/{site_id}", tags=["reports"])
def generate_energy_analysis_pdf(site_id: int, db=Depends(get_db)):
    """Generate energy analysis PDF report."""
    site = db.query(Site).filter(Site.id == site_id).first()
    if not site:
        raise HTTPException(status_code=404, detail="Site not found")
    
    bills = db.query(Bill).filter(Bill.site_id == site_id).order_by(Bill.period_end.desc()).limit(12).all()
    
    output = BytesIO()
    doc = SimpleDocTemplate(output, pagesize=A4)
    styles = getSampleStyleSheet()
    story = []
    
    story.append(Paragraph("Energy Analysis Report", styles['Title']))
    story.append(Spacer(1, 20))
    story.append(Paragraph(f"<b>Site:</b> {site.name}", styles['Normal']))
    story.append(Paragraph(f"<b>Report Period:</b> Last 12 Months", styles['Normal']))
    story.append(Spacer(1, 30))
    
    if bills:
        total_kwh = sum(b.total_kwh or 0 for b in bills)
        total_cost = sum(b.total_amount or 0 for b in bills)
        avg_monthly_kwh = total_kwh / len(bills)
        avg_monthly_cost = total_cost / len(bills)
        peak_demand = max(b.peak_kw or 0 for b in bills)
        
        story.append(Paragraph("Key Metrics", styles['Heading2']))
        metrics_data = [
            ["Metric", "Value"],
            ["Total Energy Consumption", f"{total_kwh:,.0f} kWh"],
            ["Total Energy Cost", f"${total_cost:,.2f}"],
            ["Average Monthly Consumption", f"{avg_monthly_kwh:,.0f} kWh"],
            ["Average Monthly Cost", f"${avg_monthly_cost:,.2f}"],
            ["Peak Demand", f"{peak_demand:,.1f} kW"],
            ["Average Cost per kWh", f"${total_cost/total_kwh:.4f}" if total_kwh > 0 else "N/A"],
        ]
        metrics_table = Table(metrics_data, colWidths=[200, 200])
        metrics_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#1E40AF')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('GRID', (0, 0), (-1, -1), 1, colors.grey),
        ]))
        story.append(metrics_table)
    
    doc.build(story)
    output.seek(0)
    
    return StreamingResponse(
        output,
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename=energy_analysis_{site_id}.pdf"}
    )


@app.get("/api/v1/tariffs/{tariff_id}", response_model=TariffResponse, tags=["tariffs"])
def get_tariff(tariff_id: int, db=Depends(get_db)):
    """Get tariff by ID."""
    tariff = db.query(Tariff).filter(Tariff.id == tariff_id).first()
    if not tariff:
        raise HTTPException(status_code=404, detail="Tariff not found")
    return tariff


@app.put("/api/v1/tariffs/{tariff_id}", response_model=TariffResponse, tags=["tariffs"])
def update_tariff(tariff_id: int, tariff_update: TariffCreate, db=Depends(get_db)):
    """Update an existing tariff."""
    tariff = db.query(Tariff).filter(Tariff.id == tariff_id).first()
    if not tariff:
        raise HTTPException(status_code=404, detail="Tariff not found")
    
    for key, value in tariff_update.model_dump().items():
        setattr(tariff, key, value)
    
    db.commit()
    db.refresh(tariff)
    return tariff


@app.delete("/api/v1/tariffs/{tariff_id}", tags=["tariffs"])
def delete_tariff(tariff_id: int, db=Depends(get_db)):
    """Delete a tariff."""
    tariff = db.query(Tariff).filter(Tariff.id == tariff_id).first()
    if not tariff:
        raise HTTPException(status_code=404, detail="Tariff not found")
    db.delete(tariff)
    db.commit()
    return {"message": "Tariff deleted successfully"}


# ============================================================================
# PLATFORM FOUNDATION ENDPOINTS (Phase 1)
# ============================================================================

@app.post("/api/v1/organizations", response_model=OrganizationResponse, tags=["admin"])
def create_organization(org: OrganizationCreate, db=Depends(get_db)):
    """Create a new organization."""
    db_org = Organization(**org.model_dump())
    db.add(db_org)
    db.commit()
    db.refresh(db_org)
    return db_org


@app.get("/api/v1/organizations", response_model=List[OrganizationResponse], tags=["admin"])
def list_organizations(db=Depends(get_db)):
    """List all organizations."""
    return db.query(Organization).all()


@app.get("/api/v1/organizations/{org_id}", response_model=OrganizationResponse, tags=["admin"])
def get_organization(org_id: int, db=Depends(get_db)):
    """Get organization by ID."""
    org = db.query(Organization).filter(Organization.id == org_id).first()
    if not org:
        raise HTTPException(status_code=404, detail="Organization not found")
    return org


@app.post("/api/v1/users", response_model=UserResponse, tags=["admin"])
def create_user(user: UserCreate, db=Depends(get_db)):
    """Create a new user."""
    import hashlib
    password_hash = hashlib.sha256(user.password.encode()).hexdigest()
    db_user = User(
        organization_id=user.organization_id,
        email=user.email,
        password_hash=password_hash,
        first_name=user.first_name,
        last_name=user.last_name,
        phone=user.phone,
        role=user.role
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user


@app.get("/api/v1/users", response_model=List[UserResponse], tags=["admin"])
def list_users(organization_id: Optional[int] = None, db=Depends(get_db)):
    """List users, optionally filtered by organization."""
    query = db.query(User)
    if organization_id:
        query = query.filter(User.organization_id == organization_id)
    return query.all()


@app.get("/api/v1/users/{user_id}", response_model=UserResponse, tags=["admin"])
def get_user(user_id: int, db=Depends(get_db)):
    """Get user by ID."""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user


@app.get("/api/v1/audit-logs", response_model=List[AuditLogResponse], tags=["admin"])
def list_audit_logs(
    organization_id: Optional[int] = None,
    site_id: Optional[int] = None,
    entity_type: Optional[str] = None,
    limit: int = 100,
    db=Depends(get_db)
):
    """List audit logs with optional filters."""
    query = db.query(AuditLog)
    if organization_id:
        query = query.filter(AuditLog.organization_id == organization_id)
    if site_id:
        query = query.filter(AuditLog.site_id == site_id)
    if entity_type:
        query = query.filter(AuditLog.entity_type == entity_type)
    return query.order_by(AuditLog.created_at.desc()).limit(limit).all()


@app.get("/api/v1/period-locks", response_model=List[PeriodLockResponse], tags=["admin"])
def list_period_locks(site_id: Optional[int] = None, db=Depends(get_db)):
    """List period locks."""
    query = db.query(PeriodLock)
    if site_id:
        query = query.filter(PeriodLock.site_id == site_id)
    return query.order_by(PeriodLock.period_start.desc()).all()


@app.post("/api/v1/period-locks", response_model=PeriodLockResponse, tags=["admin"])
def create_period_lock(lock: PeriodLockCreate, db=Depends(get_db)):
    """Create a new period lock."""
    db_lock = PeriodLock(**lock.model_dump())
    db.add(db_lock)
    db.commit()
    db.refresh(db_lock)
    return db_lock


@app.post("/api/v1/period-locks/{lock_id}/lock", response_model=PeriodLockResponse, tags=["admin"])
def lock_period(lock_id: int, db=Depends(get_db)):
    """Lock a period to prevent edits."""
    lock = db.query(PeriodLock).filter(PeriodLock.id == lock_id).first()
    if not lock:
        raise HTTPException(status_code=404, detail="Period lock not found")
    lock.status = PeriodStatus.LOCKED
    lock.locked_at = datetime.utcnow()
    db.commit()
    db.refresh(lock)
    return lock


# ============================================================================
# DATA QUALITY ENDPOINTS (Phase 2)
# ============================================================================

@app.get("/api/v1/data-quality/dashboard", response_model=DataQualityDashboard, tags=["data-quality"])
def get_data_quality_dashboard(site_id: Optional[int] = None, db=Depends(get_db)):
    """Get data quality dashboard summary."""
    query = db.query(Meter)
    if site_id:
        query = query.filter(Meter.site_id == site_id)
    total_meters = query.count()
    
    issues_query = db.query(QualityIssue).filter(QualityIssue.is_resolved == 0)
    open_issues = issues_query.all()
    critical_issues = [i for i in open_issues if i.severity == "critical"]
    meters_with_issues = len(set(i.meter_id for i in open_issues))
    
    return DataQualityDashboard(
        total_meters=total_meters,
        meters_with_issues=meters_with_issues,
        average_coverage=95.0,
        average_quality_score=92.5,
        open_issues_count=len(open_issues),
        critical_issues_count=len(critical_issues),
        recent_issues=[QualityIssueResponse.model_validate(i) for i in open_issues[:10]]
    )


@app.get("/api/v1/data-quality/issues", response_model=List[QualityIssueResponse], tags=["data-quality"])
def list_quality_issues(
    meter_id: Optional[int] = None,
    issue_type: Optional[QualityIssueType] = None,
    is_resolved: Optional[bool] = None,
    db=Depends(get_db)
):
    """List data quality issues with filters."""
    query = db.query(QualityIssue)
    if meter_id:
        query = query.filter(QualityIssue.meter_id == meter_id)
    if issue_type:
        query = query.filter(QualityIssue.issue_type == issue_type)
    if is_resolved is not None:
        query = query.filter(QualityIssue.is_resolved == (1 if is_resolved else 0))
    return query.order_by(QualityIssue.created_at.desc()).all()


@app.post("/api/v1/data-quality/issues/{issue_id}/resolve", response_model=QualityIssueResponse, tags=["data-quality"])
def resolve_quality_issue(issue_id: int, resolution_notes: Optional[str] = None, db=Depends(get_db)):
    """Resolve a data quality issue."""
    issue = db.query(QualityIssue).filter(QualityIssue.id == issue_id).first()
    if not issue:
        raise HTTPException(status_code=404, detail="Issue not found")
    issue.is_resolved = 1
    issue.resolved_at = datetime.utcnow()
    issue.resolution_notes = resolution_notes
    db.commit()
    db.refresh(issue)
    return issue


# ============================================================================
# VIRTUAL METER ENDPOINTS (Phase 3)
# ============================================================================

@app.get("/api/v1/virtual-meters", response_model=List[VirtualMeterResponse], tags=["virtual-meters"])
def list_virtual_meters(site_id: Optional[int] = None, db=Depends(get_db)):
    """List virtual meters."""
    query = db.query(VirtualMeter)
    if site_id:
        query = query.filter(VirtualMeter.site_id == site_id)
    return query.all()


@app.post("/api/v1/virtual-meters", response_model=VirtualMeterResponse, tags=["virtual-meters"])
def create_virtual_meter(vm: VirtualMeterCreate, db=Depends(get_db)):
    """Create a virtual meter with components."""
    db_vm = VirtualMeter(
        site_id=vm.site_id,
        name=vm.name,
        description=vm.description,
        meter_type=vm.meter_type,
        expression=vm.expression,
        unit=vm.unit
    )
    db.add(db_vm)
    db.commit()
    
    for comp in vm.components:
        db_comp = VirtualMeterComponent(
            virtual_meter_id=db_vm.id,
            meter_id=comp.meter_id,
            weight=comp.weight,
            operator=comp.operator,
            allocation_percent=comp.allocation_percent
        )
        db.add(db_comp)
    
    db.commit()
    db.refresh(db_vm)
    return db_vm


@app.get("/api/v1/virtual-meters/{vm_id}", response_model=VirtualMeterResponse, tags=["virtual-meters"])
def get_virtual_meter(vm_id: int, db=Depends(get_db)):
    """Get virtual meter by ID."""
    vm = db.query(VirtualMeter).filter(VirtualMeter.id == vm_id).first()
    if not vm:
        raise HTTPException(status_code=404, detail="Virtual meter not found")
    return vm


# ============================================================================
# PREDICTIVE MAINTENANCE ENDPOINTS (Phase 4)
# ============================================================================

@app.get("/api/v1/maintenance/alerts", response_model=List[MaintenanceAlertResponse], tags=["maintenance"])
def list_maintenance_alerts(
    asset_id: Optional[int] = None,
    status: Optional[str] = None,
    db=Depends(get_db)
):
    """List predictive maintenance alerts."""
    query = db.query(MaintenanceAlert)
    if asset_id:
        query = query.filter(MaintenanceAlert.asset_id == asset_id)
    if status:
        query = query.filter(MaintenanceAlert.status == status)
    return query.order_by(MaintenanceAlert.created_at.desc()).all()


@app.get("/api/v1/maintenance/asset-conditions", response_model=List[AssetConditionResponse], tags=["maintenance"])
def list_asset_conditions(site_id: Optional[int] = None, db=Depends(get_db)):
    """List asset conditions for a site."""
    query = db.query(AssetCondition)
    if site_id:
        query = query.join(Asset).filter(Asset.site_id == site_id)
    return query.all()


@app.post("/api/v1/maintenance/alerts/{alert_id}/acknowledge", response_model=MaintenanceAlertResponse, tags=["maintenance"])
def acknowledge_maintenance_alert(alert_id: int, db=Depends(get_db)):
    """Acknowledge a maintenance alert."""
    alert = db.query(MaintenanceAlert).filter(MaintenanceAlert.id == alert_id).first()
    if not alert:
        raise HTTPException(status_code=404, detail="Alert not found")
    alert.status = "acknowledged"
    alert.acknowledged_at = datetime.utcnow()
    db.commit()
    db.refresh(alert)
    return alert


# ============================================================================
# AI AGENT ENDPOINTS (Phase 4)
# ============================================================================

@app.post("/api/v1/agents/chat", response_model=AgentChatResponse, tags=["ai-agents"])
def chat_with_agent(request: AgentChatRequest, db=Depends(get_db)):
    """Chat with an AI agent for energy analysis."""
    session = None
    if request.session_id:
        session = db.query(AgentSession).filter(AgentSession.id == request.session_id).first()
    
    if not session:
        session = AgentSession(
            site_id=request.site_id,
            agent_type=request.agent_type
        )
        db.add(session)
        db.commit()
        db.refresh(session)
    
    user_msg = AgentMessage(
        session_id=session.id,
        role="user",
        content=request.message
    )
    db.add(user_msg)
    
    response_text = f"I've analyzed your query about '{request.message[:50]}...'. Based on the energy data for this site, I can provide insights on consumption patterns, anomalies, and optimization opportunities. What specific aspect would you like me to focus on?"
    
    agent_msg = AgentMessage(
        session_id=session.id,
        role="assistant",
        content=response_text
    )
    db.add(agent_msg)
    db.commit()
    
    return AgentChatResponse(
        session_id=session.id,
        response=response_text,
        evidence=None,
        recommendations=[]
    )


@app.get("/api/v1/recommendations", response_model=List[RecommendationResponse], tags=["ai-agents"])
def list_recommendations(
    site_id: Optional[int] = None,
    status: Optional[str] = None,
    db=Depends(get_db)
):
    """List AI-generated recommendations."""
    query = db.query(Recommendation)
    if site_id:
        query = query.filter(Recommendation.site_id == site_id)
    if status:
        query = query.filter(Recommendation.status == status)
    return query.order_by(Recommendation.created_at.desc()).all()


@app.post("/api/v1/recommendations/{rec_id}/approve", response_model=RecommendationResponse, tags=["ai-agents"])
def approve_recommendation(rec_id: int, db=Depends(get_db)):
    """Approve an AI recommendation."""
    rec = db.query(Recommendation).filter(Recommendation.id == rec_id).first()
    if not rec:
        raise HTTPException(status_code=404, detail="Recommendation not found")
    rec.status = "approved"
    rec.approved_at = datetime.utcnow()
    db.commit()
    db.refresh(rec)
    return rec


# ============================================================================
# FORECASTING ENDPOINTS (Phase 4)
# ============================================================================

@app.post("/api/v1/forecasts", response_model=ForecastResponse, tags=["forecasting"])
def create_forecast(request: ForecastRequest, db=Depends(get_db)):
    """Create a new forecast job."""
    job = ForecastJob(
        site_id=request.site_id,
        meter_id=request.meter_id,
        forecast_type=request.forecast_type,
        horizon_hours=request.horizon_hours,
        status="completed"
    )
    db.add(job)
    db.commit()
    db.refresh(job)
    
    forecast_data = []
    base_time = datetime.utcnow()
    for i in range(request.horizon_hours):
        predicted = 100 + 50 * (0.5 - abs(12 - (i % 24)) / 12)
        point = ForecastSeries(
            job_id=job.id,
            timestamp=base_time + timedelta(hours=i),
            predicted_value=predicted,
            lower_bound=predicted * 0.9,
            upper_bound=predicted * 1.1,
            confidence=0.85
        )
        db.add(point)
        forecast_data.append(ForecastPointResponse(
            timestamp=point.timestamp,
            predicted_value=point.predicted_value,
            lower_bound=point.lower_bound,
            upper_bound=point.upper_bound,
            confidence=point.confidence
        ))
    
    db.commit()
    
    return ForecastResponse(
        job_id=job.id,
        site_id=request.site_id,
        forecast_type=request.forecast_type,
        horizon_hours=request.horizon_hours,
        status="completed",
        data=forecast_data
    )


@app.get("/api/v1/forecasts/{job_id}", response_model=ForecastResponse, tags=["forecasting"])
def get_forecast(job_id: int, db=Depends(get_db)):
    """Get forecast results by job ID."""
    job = db.query(ForecastJob).filter(ForecastJob.id == job_id).first()
    if not job:
        raise HTTPException(status_code=404, detail="Forecast job not found")
    
    series = db.query(ForecastSeries).filter(ForecastSeries.job_id == job_id).all()
    
    return ForecastResponse(
        job_id=job.id,
        site_id=job.site_id,
        forecast_type=job.forecast_type,
        horizon_hours=job.horizon_hours,
        status=job.status,
        data=[ForecastPointResponse(
            timestamp=s.timestamp,
            predicted_value=s.predicted_value,
            lower_bound=s.lower_bound,
            upper_bound=s.upper_bound,
            confidence=s.confidence
        ) for s in series]
    )


# ============================================================================
# CONTROL ENDPOINTS (Phase 4)
# ============================================================================

@app.get("/api/v1/control-rules", response_model=List[ControlRuleResponse], tags=["control"])
def list_control_rules(site_id: Optional[int] = None, db=Depends(get_db)):
    """List automation control rules."""
    query = db.query(ControlRule)
    if site_id:
        query = query.filter(ControlRule.site_id == site_id)
    return query.all()


@app.post("/api/v1/control-rules", response_model=ControlRuleResponse, tags=["control"])
def create_control_rule(rule: ControlRuleCreate, db=Depends(get_db)):
    """Create a new control rule."""
    db_rule = ControlRule(**rule.model_dump())
    db.add(db_rule)
    db.commit()
    db.refresh(db_rule)
    return db_rule


@app.get("/api/v1/control-commands", response_model=List[ControlCommandResponse], tags=["control"])
def list_control_commands(
    asset_id: Optional[int] = None,
    status: Optional[str] = None,
    db=Depends(get_db)
):
    """List control commands."""
    query = db.query(ControlCommand)
    if asset_id:
        query = query.filter(ControlCommand.asset_id == asset_id)
    if status:
        query = query.filter(ControlCommand.status == status)
    return query.order_by(ControlCommand.created_at.desc()).all()


# ============================================================================
# PV SIZING ENDPOINT (Phase 3)
# ============================================================================

@app.post("/api/v1/analysis/pv-sizing", response_model=PVSizingResponse, tags=["analysis"])
def calculate_pv_sizing(request: PVSizingRequest, db=Depends(get_db)):
    """Calculate optimal PV system sizing for a site."""
    panel_area_per_kwp = 5.0
    max_capacity_kwp = request.roof_area_sqm / panel_area_per_kwp
    
    peak_sun_hours = 4.5
    annual_production_per_kwp = peak_sun_hours * 365 * request.panel_efficiency * (1 - request.system_losses)
    
    annual_consumption = request.average_monthly_consumption_kwh * 12
    recommended_capacity = min(
        annual_consumption / annual_production_per_kwp * 0.8,
        max_capacity_kwp
    )
    
    estimated_production = recommended_capacity * annual_production_per_kwp
    estimated_savings = estimated_production * request.electricity_rate
    installation_cost = recommended_capacity * request.installation_cost_per_kwp
    
    payback_years = installation_cost / estimated_savings if estimated_savings > 0 else 999
    
    co2_factor = 0.5
    co2_offset = estimated_production * co2_factor / 1000
    
    monthly_factors = [0.7, 0.75, 0.85, 0.95, 1.05, 1.15, 1.2, 1.15, 1.0, 0.85, 0.75, 0.65]
    monthly_production = [estimated_production / 12 * f for f in monthly_factors]
    
    return PVSizingResponse(
        recommended_capacity_kwp=round(recommended_capacity, 2),
        estimated_annual_production_kwh=round(estimated_production, 0),
        estimated_annual_savings=round(estimated_savings, 2),
        estimated_installation_cost=round(installation_cost, 2),
        simple_payback_years=round(payback_years, 1),
        co2_offset_tonnes_per_year=round(co2_offset, 2),
        roof_utilization_percent=round(recommended_capacity / max_capacity_kwp * 100, 1),
        monthly_production=[round(p, 0) for p in monthly_production]
    )


# ============================================================================
# AUTHENTICATION ENDPOINTS
# ============================================================================

def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db=Depends(get_db)
):
    """Get the current authenticated user from JWT token."""
    if not credentials:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    token = credentials.credentials
    payload = decode_access_token(token)
    
    if not payload:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    user_id = payload.get("sub")
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )
    
    user = db.query(User).filter(User.id == int(user_id)).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Account is disabled",
        )
    
    return user


def get_optional_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db=Depends(get_db)
):
    """Get the current user if authenticated, otherwise return None."""
    if not credentials:
        return None
    
    try:
        return get_current_user(credentials, db)
    except HTTPException:
        return None


class RoleChecker:
    """Dependency class for checking user roles."""
    
    def __init__(self, min_role: str):
        self.min_role = min_role
        self.min_level = get_role_level(min_role)
    
    def __call__(self, user = Depends(get_current_user)):
        user_level = get_role_level(user.role.value if hasattr(user.role, 'value') else str(user.role))
        if user_level < self.min_level:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Access denied. Minimum role required: {self.min_role}"
            )
        return user


def require_role(min_role: str):
    """Dependency factory for role-based access control."""
    return RoleChecker(min_role)


require_viewer = Depends(require_role("viewer"))
require_engineer = Depends(require_role("engineer"))
require_site_manager = Depends(require_role("site_manager"))
require_org_admin = Depends(require_role("org_admin"))
require_super_admin = Depends(require_role("super_admin"))


@app.post("/api/v1/auth/register", response_model=TokenResponse, tags=["auth"])
def register(request: RegisterRequest, db=Depends(get_db)):
    """Register a new user account."""
    existing_user = db.query(User).filter(User.email == request.email).first()
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    org_name = request.organization_name or f"{request.email.split('@')[0]}'s Organization"
    slug = org_name.lower().replace(" ", "-").replace("'", "")[:50]
    
    existing_org = db.query(Organization).filter(Organization.slug == slug).first()
    if existing_org:
        slug = f"{slug}-{secrets.token_hex(4)}"
    
    organization = Organization(
        name=org_name,
        slug=slug,
        is_active=1
    )
    db.add(organization)
    db.flush()
    
    user = User(
        organization_id=organization.id,
        email=request.email,
        password_hash=get_password_hash(request.password),
        first_name=request.first_name,
        last_name=request.last_name,
        role=UserRole.ORG_ADMIN,
        is_active=1
    )
    db.add(user)
    db.commit()
    db.refresh(user)
    
    access_token = create_access_token(data={"sub": str(user.id)})
    
    return TokenResponse(
        access_token=access_token,
        expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60,
        user=UserResponse(
            id=user.id,
            organization_id=user.organization_id,
            email=user.email,
            first_name=user.first_name,
            last_name=user.last_name,
            phone=user.phone,
            role=user.role,
            is_active=bool(user.is_active),
            mfa_enabled=bool(user.mfa_enabled),
            last_login_at=user.last_login_at,
            created_at=user.created_at
        )
    )


@app.post("/api/v1/auth/login", response_model=TokenResponse, tags=["auth"])
def login(request: LoginRequest, db=Depends(get_db)):
    """Authenticate user and return access token."""
    user = db.query(User).filter(User.email == request.email).first()
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password"
        )
    
    if user.locked_until and user.locked_until > datetime.utcnow():
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Account is temporarily locked due to too many failed login attempts"
        )
    
    if not verify_password(request.password, user.password_hash):
        user.failed_login_attempts = (user.failed_login_attempts or 0) + 1
        if user.failed_login_attempts >= 5:
            user.locked_until = datetime.utcnow() + timedelta(minutes=15)
        db.commit()
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password"
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Account is disabled"
        )
    
    user.failed_login_attempts = 0
    user.locked_until = None
    user.last_login_at = datetime.utcnow()
    db.commit()
    db.refresh(user)
    
    access_token = create_access_token(data={"sub": str(user.id)})
    
    return TokenResponse(
        access_token=access_token,
        expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60,
        user=UserResponse(
            id=user.id,
            organization_id=user.organization_id,
            email=user.email,
            first_name=user.first_name,
            last_name=user.last_name,
            phone=user.phone,
            role=user.role,
            is_active=bool(user.is_active),
            mfa_enabled=bool(user.mfa_enabled),
            last_login_at=user.last_login_at,
            created_at=user.created_at
        )
    )


@app.get("/api/v1/auth/me", response_model=AuthUserResponse, tags=["auth"])
def get_current_user_info(current_user: User = Depends(get_current_user), db=Depends(get_db)):
    """Get current authenticated user information."""
    org = db.query(Organization).filter(Organization.id == current_user.organization_id).first()
    
    return AuthUserResponse(
        id=current_user.id,
        email=current_user.email,
        first_name=current_user.first_name,
        last_name=current_user.last_name,
        role=current_user.role,
        organization_id=current_user.organization_id,
        organization_name=org.name if org else None,
        is_active=bool(current_user.is_active)
    )


@app.post("/api/v1/auth/logout", tags=["auth"])
def logout(current_user: User = Depends(get_current_user)):
    """Logout current user (client-side token removal)."""
    return {"message": "Successfully logged out"}


@app.post("/api/v1/auth/change-password", tags=["auth"])
def change_password(
    current_password: str = Form(...),
    new_password: str = Form(..., min_length=8),
    current_user: User = Depends(get_current_user),
    db=Depends(get_db)
):
    """Change the current user's password."""
    if not verify_password(current_password, current_user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Current password is incorrect"
        )
    
    current_user.password_hash = get_password_hash(new_password)
    db.commit()
    
    return {"message": "Password changed successfully"}


# ============================================================================
# DATA INGESTION ENDPOINTS
# ============================================================================

import io
import pandas as pd

class ParsedFileResponse(BaseModel):
    """Response schema for parsed file data."""
    headers: List[str]
    preview: List[Dict[str, Any]]
    totalRows: int


class ImportResultResponse(BaseModel):
    """Response schema for import results."""
    imported: int
    errors: int
    message: str


@app.post("/api/v1/data-ingestion/parse", response_model=ParsedFileResponse, tags=["data-ingestion"])
async def parse_data_file(file: UploadFile = File(...)):
    """Parse a CSV or Excel file and return headers with preview data."""
    if not file.filename:
        raise HTTPException(status_code=400, detail="No file provided")
    
    filename = file.filename.lower()
    content = await file.read()
    
    try:
        if filename.endswith('.csv'):
            df = pd.read_csv(io.BytesIO(content))
        elif filename.endswith(('.xlsx', '.xls')):
            df = pd.read_excel(io.BytesIO(content))
        else:
            raise HTTPException(status_code=400, detail="Unsupported file format. Use CSV or Excel.")
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Failed to parse file: {str(e)}")
    
    df = df.fillna('')
    df = df.astype(str)
    
    preview_rows = df.head(5).to_dict('records')
    
    return ParsedFileResponse(
        headers=list(df.columns),
        preview=preview_rows,
        totalRows=len(df)
    )


@app.post("/api/v1/data-ingestion/import", response_model=ImportResultResponse, tags=["data-ingestion"])
async def import_data_file(
    file: UploadFile = File(...),
    mappings: str = Form(...),
    db=Depends(get_db)
):
    """Import meter readings from a file with column mappings."""
    import json
    
    if not file.filename:
        raise HTTPException(status_code=400, detail="No file provided")
    
    try:
        column_mappings = json.loads(mappings)
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Invalid mappings JSON")
    
    filename = file.filename.lower()
    content = await file.read()
    
    try:
        if filename.endswith('.csv'):
            df = pd.read_csv(io.BytesIO(content))
        elif filename.endswith(('.xlsx', '.xls')):
            df = pd.read_excel(io.BytesIO(content))
        else:
            raise HTTPException(status_code=400, detail="Unsupported file format")
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Failed to parse file: {str(e)}")
    
    mapping_dict = {m['sourceColumn']: m['targetField'] for m in column_mappings if m['targetField'] != 'ignore'}
    
    imported_count = 0
    error_count = 0
    
    for _, row in df.iterrows():
        try:
            timestamp_col = next((k for k, v in mapping_dict.items() if v == 'timestamp'), None)
            meter_id_col = next((k for k, v in mapping_dict.items() if v == 'meter_id'), None)
            reading_col = next((k for k, v in mapping_dict.items() if v == 'reading_kwh'), None)
            
            if not all([timestamp_col, meter_id_col, reading_col]):
                error_count += 1
                continue
            
            meter = db.query(Meter).filter(Meter.meter_id == str(row[meter_id_col])).first()
            if not meter:
                meter = db.query(Meter).filter(Meter.name.ilike(f"%{row[meter_id_col]}%")).first()
            
            if not meter:
                error_count += 1
                continue
            
            try:
                reading_time = pd.to_datetime(row[timestamp_col])
            except:
                error_count += 1
                continue
            
            try:
                reading_value = float(row[reading_col])
            except:
                error_count += 1
                continue
            
            reading = MeterReading(
                meter_id=meter.id,
                timestamp=reading_time,
                reading_kwh=reading_value,
                reading_type='imported'
            )
            db.add(reading)
            imported_count += 1
            
        except Exception:
            error_count += 1
    
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    
    return ImportResultResponse(
        imported=imported_count,
        errors=error_count,
        message=f"Successfully imported {imported_count} readings. {error_count} rows had errors."
    )


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
